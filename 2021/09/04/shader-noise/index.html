<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>shader noise | 大潘子的文字角落</title><meta name="author" content="Pan"><meta name="copyright" content="Pan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Noise噪声">
<meta property="og:type" content="article">
<meta property="og:title" content="shader noise">
<meta property="og:url" content="https://flippy-bird.github.io/2021/09/04/shader-noise/index.html">
<meta property="og:site_name" content="大潘子的文字角落">
<meta property="og:description" content="Noise噪声">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://flippy-bird.github.io/covers/24.webp">
<meta property="article:published_time" content="2021-09-04T05:00:34.000Z">
<meta property="article:modified_time" content="2026-01-16T10:40:28.946Z">
<meta property="article:author" content="Pan">
<meta property="article:tag" content="shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://flippy-bird.github.io/covers/24.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "shader noise",
  "url": "https://flippy-bird.github.io/2021/09/04/shader-noise/",
  "image": "https://flippy-bird.github.io/covers/24.webp",
  "datePublished": "2021-09-04T05:00:34.000Z",
  "dateModified": "2026-01-16T10:40:28.946Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pan",
      "url": "https://flippy-bird.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favion.png"><link rel="canonical" href="https://flippy-bird.github.io/2021/09/04/shader-noise/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'shader noise',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/covers/24.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">大潘子的文字角落</span></a><a class="nav-page-title" href="/"><span class="site-name">shader noise</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">shader noise</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-04T05:00:34.000Z" title="发表于 2021-09-04 13:00:34">2021-09-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-16T10:40:28.946Z" title="更新于 2026-01-16 18:40:28">2026-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Noise噪声"><a href="#Noise噪声" class="headerlink" title="Noise噪声"></a>Noise噪声</h2><span id="more"></span>



<h3 id="什么是噪声"><a href="#什么是噪声" class="headerlink" title="什么是噪声"></a>什么是噪声</h3><p><strong>噪声 &#x3D; 随机 + 连续</strong></p>
<p>在图形学中，我们使用噪声就是为了把一些随机变量来引入到程序中。从程序角度来说，噪声很好理解，我们希望给定一个输入，程序可以给出一个输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_type <span class="title">noise</span><span class="params">(value_type p)</span> </span>&#123;   <span class="comment">//简单理解为程序语言中的random即可</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的输入和输出类型的维数可以是不同的组合，例如输入二维输出一维，输入二维输出二维等。我们今天就是想讨论一下上面函数中的实现部分是长什么样的。</p>
<h3 id="噪声的分类"><a href="#噪声的分类" class="headerlink" title="噪声的分类"></a>噪声的分类</h3><p>根据wiki，由程序产生噪声的方法大致可以分为两类：</p>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_category.png" alt="noise_category" loading='lazy'></p>
<p>Perlin噪声、Simplex噪声和Value噪声在性能上大致满足：Perlin噪声(O(2^n)) &lt; Value噪声&lt; Simplex噪声(O(n^2))，Simplex噪声性能最好,效果也最好。</p>
<h3 id="Perlin-Noise"><a href="#Perlin-Noise" class="headerlink" title="Perlin Noise"></a>Perlin Noise</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>概括来说，Perlin噪声的实现需要三个步骤：</p>
<ol>
<li><p>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</p>
</li>
<li><p>输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2的n次方个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2的n次方个点乘结果。</p>
</li>
<li><p>使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)&#x3D;3t^2−2t^3，在2002年的论文6中，Perlin改进为s(t)&#x3D;6t^5−15t^4+10t^3，这里简单解释一下，为什么不直接使用s(t)&#x3D;t，即线性插值。直接使用的线性插值的话，它的一阶导在晶格顶点处（即t &#x3D; 0或t &#x3D; 1）不为0，会造成明显的不连续性。s(t)&#x3D;3t^2−2t^3，在一阶导满足连续性，s(t)&#x3D;6t^5−15t^4+10t^3，在二阶导上仍然满足连续性。<br>我们可以用下面的图来表示上面的第一步和第二步：</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/perlin_noise.png" alt="perlin_noise" loading='lazy'></p>
<h4 id="Perlin噪声的实现"><a href="#Perlin噪声的实现" class="headerlink" title="Perlin噪声的实现"></a>Perlin噪声的实现</h4><p>主要代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">hash22</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="built_in">vec2</span>( <span class="built_in">dot</span>(p,<span class="built_in">vec2</span>(<span class="number">127.1</span>,<span class="number">311.7</span>)),</span><br><span class="line">              <span class="built_in">dot</span>(p,<span class="built_in">vec2</span>(<span class="number">269.5</span>,<span class="number">183.3</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span> + <span class="number">2.0</span> * <span class="built_in">fract</span>(<span class="built_in">sin</span>(p)*<span class="number">43758.5453123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">perlin_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 pi = <span class="built_in">floor</span>(p);</span><br><span class="line">    vec2 pf = p - pi;</span><br><span class="line"></span><br><span class="line">    vec2 w = pf * pf * (<span class="number">3.0</span> - <span class="number">2.0</span> * pf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(<span class="built_in">mix</span>(<span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), </span><br><span class="line">                   <span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), w.x), </span><br><span class="line">               <span class="built_in">mix</span>(<span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), </span><br><span class="line">                   <span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), w.x),</span><br><span class="line">               w.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现实际是简化版的，我们在算梯度的时候直接取随机值，而没有归一化到单位圆内。</p>
<h3 id="Value-Noise"><a href="#Value-Noise" class="headerlink" title="Value Noise"></a>Value Noise</h3><p>它把原来的梯度替换成了一个简单的伪随机值，我们也<strong>不需要进行点乘操作</strong>，而直接把晶格顶点处的随机值按权重相加即可。如下图，即只需要将蓝色矩形中四个顶点的随机值按权重相加。</p>
<img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/value_noise1.png" alt="value_noise1" style="zoom:67%;" / loading='lazy'> 

<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>和Perlin噪声一样，它也是一种基于晶格的噪声，也需要三个步骤：</p>
<ol>
<li><p>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的值（Value）。对于二维的Value噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</p>
</li>
<li><p>输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2 个），得到这些顶点的伪随机值。</p>
</li>
<li><p>使用缓和曲线（ease curves）来计算它们的权重和。同样，缓和曲线可以是s(t) &#x3D; 3t^2 - 2t^2,也可以是s(t)&#x3D;6t^5−15t^4+10t^3（如果二阶导不连续对效果影响较大时）。</p>
</li>
</ol>
<p>Value噪声比Perlin噪声的实现更加简单，并且需要的乘法和加法操作也更少，它只需要得到晶格顶点的随机值再把它们按权重相加即可。</p>
<h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">value_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 pi = <span class="built_in">floor</span>(p);</span><br><span class="line">    vec2 pf = p - pi;</span><br><span class="line"></span><br><span class="line">    vec2 w = pf * pf * (<span class="number">3.0</span> - <span class="number">2.0</span> * pf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(<span class="built_in">mix</span>(<span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), <span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), w.x),</span><br><span class="line">               <span class="built_in">mix</span>(<span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), <span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), w.x),</span><br><span class="line">               w.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplex-Noise"><a href="#Simplex-Noise" class="headerlink" title="Simplex Noise"></a>Simplex Noise</h3><p>Simplex噪声的计算复杂度为O(n^2^)，优于Perlin噪声的O(2n)。而且在效果上，Simplex噪声也克服了经典的Perlin噪声在某些视觉问题。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/simplex_noise.png" alt="simplex_noise" style="zoom:65%;" / loading='lazy'>



<p>和perlin实现的区别是将上面的矩形换成了一个三角形，所以现在存在一个问题：如何找到上面图形的三个顶点，解决方案如下图：</p>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/simplex_noise1.png" alt="simplex_noise1" loading='lazy'></p>
<p>将等边三角形倾斜即可转化为矩形，找到顶点后，再做逆向操作即可。</p>
<h4 id="主要代码-1"><a href="#主要代码-1" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">simplex_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> K1 = <span class="number">0.366025404</span>; <span class="comment">// (sqrt(3)-1)/2;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> K2 = <span class="number">0.211324865</span>; <span class="comment">// (3-sqrt(3))/6;</span></span><br><span class="line"></span><br><span class="line">    vec2 i = <span class="built_in">floor</span>(p + (p.x + p.y) * K1);</span><br><span class="line"></span><br><span class="line">    vec2 a = p - (i - (i.x + i.y) * K2);</span><br><span class="line">    vec2 o = (a.x &lt; a.y) ? <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>) : <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    vec2 b = a - o + K2;</span><br><span class="line">    vec2 c = a - <span class="number">1.0</span> + <span class="number">2.0</span> * K2;</span><br><span class="line"></span><br><span class="line">    vec3 h = <span class="built_in">max</span>(<span class="number">0.5</span> - <span class="built_in">vec3</span>(<span class="built_in">dot</span>(a, a), <span class="built_in">dot</span>(b, b), <span class="built_in">dot</span>(c, c)), <span class="number">0.0</span>);</span><br><span class="line">    vec3 n = h * h * h * h * <span class="built_in">vec3</span>(<span class="built_in">dot</span>(a, <span class="built_in">hash22</span>(i)), <span class="built_in">dot</span>(b, <span class="built_in">hash22</span>(i + o)), <span class="built_in">dot</span>(c, <span class="built_in">hash22</span>(i + <span class="number">1.0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(<span class="built_in">vec3</span>(<span class="number">70.0</span>, <span class="number">70.0</span>, <span class="number">70.0</span>), n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wavelet-Noise"><a href="#Wavelet-Noise" class="headerlink" title="Wavelet Noise"></a>Wavelet Noise</h3><p>当使用一个3D噪声去绘制2D纹理表面时，容易出现走样和细节丢失的情形</p>
<img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/waveletNoise.png" alt="waveletNoise" style="zoom: 67%;" / loading='lazy'> 

<p>Wavelet Noise正是为了解决这个问题</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/wavelet_noise_generation.png" alt="wavelet_noise_generation" style="zoom:50%;" / loading='lazy'>         

<p>主要经过了4个步骤：</p>
<ol>
<li>产生一个噪声图R</li>
<li>降采样</li>
<li>上采样</li>
<li>将原图减去上采样的纹理图得到结果图</li>
</ol>
<h3 id="Worley-Noise"><a href="#Worley-Noise" class="headerlink" title="Worley Noise"></a>Worley Noise</h3><p>Worley噪声属于一种细胞噪声，就是噪声值是由随机的特征点向外扩散，最终看起来像是有一个个晶胞一样的效果。也叫网格噪声，<strong>是基于距离场</strong></p>
<p>这种细胞噪声可以应用于模拟皮革，水面等等。（Worley噪声是Voronoi噪声的改进版）</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>把空间分割成网格（cells），每个网格对应一个特征点。另外，为避免网格交界区域的偏差，我们需要计算像素点到相邻网格中的特征点的距离。这就是 <a target="_blank" rel="noopener" href="http://www.rhythmiccanvas.com/research/papers/worley.pdf">Steven Worley 的论文</a>中的主要思想。最后，每个像素点只需要计算到九个特征点的距离：他所在的网格的特征点和相邻的八个网格的特征点。</p>
<img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/worley_noise_principle.png" alt="worley_noise_principle" style="zoom: 67%;" / loading='lazy'> 

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> r(<span class="type">vec2</span> n)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="type">vec2</span>(r(n.x*<span class="number">23.62</span><span class="number">-300.0</span>+n.y*<span class="number">34.35</span>),r(n.x*<span class="number">45.13</span>+<span class="number">256.0</span>+n.y*<span class="number">38.89</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Worley2D(<span class="type">vec2</span> n,<span class="type">float</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    n /= s;</span><br><span class="line">    <span class="type">float</span> dis = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>;x&lt;=<span class="number">1</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>;y&lt;=<span class="number">1</span>;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">vec2</span> p = <span class="built_in">floor</span>(n)+<span class="type">vec2</span>(x,y);</span><br><span class="line">            p = r(p)+<span class="type">vec2</span>(x,y)-<span class="built_in">fract</span>(n);</span><br><span class="line">            dis = <span class="built_in">min</span>(dis, <span class="built_in">dot</span>(p, p));        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - <span class="built_in">sqrt</span>(dis);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> WorleyFBM(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> amplitude = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> gain = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> lacunarity = <span class="number">2.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> value = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="type">int</span> STEPS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; STEPS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">     	value += Worley2D(uv, <span class="number">2.0</span>) * amplitude;</span><br><span class="line">        amplitude *= gain;</span><br><span class="line">        uv *= lacunarity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FBM"><a href="#FBM" class="headerlink" title="FBM"></a>FBM</h3><p>单独一个Perlin噪声虽然也有一定用处，但是效果往往很无趣。因此，Perlin指出可以使用不同的函数组合来得到更有意思的结果，这些函数组合通常就是指通过分形叠加（fractal sum）。</p>
<ul>
<li><strong>fbm 分形噪声</strong></li>
</ul>
<p>noise的叠加公式如下：<br>$$<br>noise(p) + 1&#x2F;2 noise(2P) + 1&#x2F;4 noise(4p) + …<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fbm 叠加分形噪声</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">4.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面叠加了5层，并把初始化采样距离设置为4，这都是可以自定义的。这种噪声可以用来模拟石头、山脉这类物体。</p>
<ul>
<li><strong>对噪声返回值进行了取绝对值操作。它使用的公式如下</strong>：</li>
</ul>
<p>$$<br>|noise(p)| + 1&#x2F;2|noise(2p)| + 1&#x2F;4|noise(4p)|+….<br>$$</p>
<p>它对应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum_abs</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">7.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于进行了绝对值操作，因此会在0值变化处出现不连续性，形成一些尖锐的效果。通过合适的颜色叠加，**我们可以用这种噪声来模拟火焰、云朵这些物体。**Perlin把这个公式称为turbulence（湍流？），因为它看起来挺像的。</p>
<ul>
<li><strong>在之前turbulnece公式的基础上使用了一个关于表面x分量的正选函数：</strong></li>
</ul>
<p>$$<br>sin(x+|noise(p) + 1&#x2F;2|noise(2p)+ 1&#x2F;4|noise(4p)|+…)<br>$$</p>
<p>这个公式可以让表面沿着x方向形成一个条纹状的结构。Perlin使用这个公式模拟了一些大理石材质。我们的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum_abs_sin</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">7.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f = <span class="built_in">sin</span>(f + p.x/<span class="number">32.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多层叠加，每层noise添加位移和旋转"><a href="#多层叠加，每层noise添加位移和旋转" class="headerlink" title="多层叠加，每层noise添加位移和旋转"></a>多层叠加，每层noise添加位移和旋转</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tjw02241035621611/article/details/80048713">中级Shader教程07 熔岩Lava</a></p>
</blockquote>
<p>通过FBM构造基本形态，在FBM添加点变化：1.每一层的移动速度不一样  2.每层的旋转不一样</p>
<p>相关代码</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fbm ( <span class="keyword">in</span> <span class="type">vec2</span> _st) &#123;</span><br><span class="line">    <span class="type">float</span> v = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> shift = <span class="type">vec2</span>(<span class="number">100.0</span>);</span><br><span class="line">    <span class="comment">// Rotate to reduce axial bias</span></span><br><span class="line">    <span class="type">mat2</span> rot = <span class="type">mat2</span>(<span class="built_in">cos</span>(<span class="number">0.5</span>), <span class="built_in">sin</span>(<span class="number">0.5</span>),</span><br><span class="line">                    -<span class="built_in">sin</span>(<span class="number">0.5</span>), <span class="built_in">cos</span>(<span class="number">0.50</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_OCTAVES; ++i) &#123;</span><br><span class="line">        v += a * noise(_st);</span><br><span class="line">        _st = rot * _st * <span class="number">2.0</span> + shift;    <span class="comment">//***********************************注意这里乘以了一个矩阵，并且加上了一个偏移量</span></span><br><span class="line">        a *= <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="域翘曲"><a href="#域翘曲" class="headerlink" title="域翘曲"></a>域翘曲</h4><blockquote>
<p>[<a target="_blank" rel="noopener" href="https://www.iquilezles.org/www/articles/warp/warp.htm">domain warping - 2002</a>]</p>
</blockquote>
<p><em>f(p) &#x3D; fbm( p + fbm( p + fbm( p ) ) )</em></p>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/warp_fbm.png" alt="warp_fbm" loading='lazy'> </p>
<h3 id="可平埔的噪声"><a href="#可平埔的噪声" class="headerlink" title="可平埔的噪声"></a>可平埔的噪声</h3><p>目前公认比较好的一种做法，就是在2n维上生成n维可平铺的噪声。</p>
<blockquote>
<p>这种方法是思想是，由于我们想要每个维度都是无缝的，也就是当该维度的值从0变成1的过程中，0和1之间比较是平滑过渡的，这让我们想起了“圆”，绕圆一周就是对该维度的采样过程，这样就可以保证无缝了。因此，对于二维噪声中的x轴，我们会在四维空间下的xz平面上的一个圆上进行采样，而二维噪声的y轴，则会在四维空间下的yw平面上的一个圆上进行采样。这个转化过程很简单，我们只需要使用三角函数sin和cos即可把二维采样坐标转化到单位圆上。同样，三维空间的也是类似的，我们会在六维空间下计算。这种方法不仅适用于Perlin噪声，像Worley噪声这种也同样是适合的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></p>
</blockquote>
<h3 id="Curl-Noise"><a href="#Curl-Noise" class="headerlink" title="Curl Noise"></a>Curl Noise</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a></p>
</blockquote>
<h3 id="noise-的应用"><a href="#noise-的应用" class="headerlink" title="noise 的应用"></a>noise 的应用</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://devmag.org.za/2009/04/25/perlin-noise/"><strong>How to Use Perlin Noise in Your Games</strong></a></p>
</blockquote>
<blockquote>
<p><strong>Perlin noise can be used to blend between two textures</strong>, as shown in following. You should use Perlin noise with very high contrast to prevent textures from looking fuzzy. The following code snippet shows how to blend two images using Perlin noise.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_application.png" alt="noise_application" loading='lazy'></p>
<h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/70144964">使用噪音模拟云的效果</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@maksimtianblue/unity-shader-2d%E5%8A%A8%E6%80%81%E4%BA%91%E5%BD%A9-5f26d445a80a">2D动态云彩</a></p>
</blockquote>
<p>生成云的shadertoy代码如下</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudscale = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> speed = <span class="number">0.03</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> clouddark = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudlight = <span class="number">0.3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudcover = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudalpha = <span class="number">8.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> skytint = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">vec3</span> skycolour1 = <span class="type">vec3</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="type">vec3</span> skycolour2 = <span class="type">vec3</span>(<span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">mat2</span> m = <span class="type">mat2</span>( <span class="number">1.6</span>,  <span class="number">1.2</span>, <span class="number">-1.2</span>,  <span class="number">1.6</span> );</span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> hash( <span class="type">vec2</span> p ) &#123;</span><br><span class="line">	p = <span class="type">vec2</span>(<span class="built_in">dot</span>(p,<span class="type">vec2</span>(<span class="number">127.1</span>,<span class="number">311.7</span>)), <span class="built_in">dot</span>(p,<span class="type">vec2</span>(<span class="number">269.5</span>,<span class="number">183.3</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1.0</span> + <span class="number">2.0</span>*<span class="built_in">fract</span>(<span class="built_in">sin</span>(p)*<span class="number">43758.5453123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> noise( <span class="keyword">in</span> <span class="type">vec2</span> p ) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> K1 = <span class="number">0.366025404</span>; <span class="comment">// (sqrt(3)-1)/2;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> K2 = <span class="number">0.211324865</span>; <span class="comment">// (3-sqrt(3))/6;</span></span><br><span class="line">	<span class="type">vec2</span> i = <span class="built_in">floor</span>(p + (p.x+p.y)*K1);	</span><br><span class="line">    <span class="type">vec2</span> a = p - i + (i.x+i.y)*K2;</span><br><span class="line">    <span class="type">vec2</span> o = (a.x&gt;a.y) ? <span class="type">vec2</span>(<span class="number">1.0</span>,<span class="number">0.0</span>) : <span class="type">vec2</span>(<span class="number">0.0</span>,<span class="number">1.0</span>); <span class="comment">//vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));</span></span><br><span class="line">    <span class="type">vec2</span> b = a - o + K2;</span><br><span class="line">	<span class="type">vec2</span> c = a - <span class="number">1.0</span> + <span class="number">2.0</span>*K2;</span><br><span class="line">    <span class="type">vec3</span> h = <span class="built_in">max</span>(<span class="number">0.5</span>-<span class="type">vec3</span>(<span class="built_in">dot</span>(a,a), <span class="built_in">dot</span>(b,b), <span class="built_in">dot</span>(c,c) ), <span class="number">0.0</span> );</span><br><span class="line">	<span class="type">vec3</span> n = h*h*h*h*<span class="type">vec3</span>( <span class="built_in">dot</span>(a,hash(i+<span class="number">0.0</span>)), <span class="built_in">dot</span>(b,hash(i+o)), <span class="built_in">dot</span>(c,hash(i+<span class="number">1.0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(n, <span class="type">vec3</span>(<span class="number">70.0</span>));	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fbm(<span class="type">vec2</span> n) &#123;</span><br><span class="line">	<span class="type">float</span> total = <span class="number">0.0</span>, amplitude = <span class="number">0.1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		total += noise(n) * amplitude;</span><br><span class="line">		n = m * n;</span><br><span class="line">		amplitude *= <span class="number">0.4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord ) &#123;</span><br><span class="line">    <span class="type">vec2</span> p = fragCoord.xy / iResolution.xy;</span><br><span class="line">	<span class="type">vec2</span> uv = p*<span class="type">vec2</span>(iResolution.x/iResolution.y,<span class="number">1.0</span>);    </span><br><span class="line">    <span class="type">float</span> time = iTime * speed;</span><br><span class="line">    <span class="type">float</span> q = fbm(uv * cloudscale * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ridged noise shape</span></span><br><span class="line">	<span class="type">float</span> r = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//noise shape</span></span><br><span class="line">	<span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// uv = p*vec2(iResolution.x/iResolution.y,1.0);</span></span><br><span class="line">	uv *= cloudscale;</span><br><span class="line">    uv -= q - time;    </span><br><span class="line">    <span class="type">float</span> weight = <span class="number">0.7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">		f += weight*noise( uv );    </span><br><span class="line">        uv = m*uv + time;</span><br><span class="line">		weight *= <span class="number">0.6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f *= r + f;</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec3</span> skycolour = <span class="built_in">mix</span>(skycolour2, skycolour1, p.y);</span><br><span class="line">    <span class="type">vec3</span> cloudcolour = <span class="type">vec3</span>(<span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">0.9</span>) * clouddark;</span><br><span class="line">    f = cloudcover + cloudalpha*f; </span><br><span class="line">    <span class="type">vec3</span> result = <span class="built_in">mix</span>(skycolour, <span class="built_in">clamp</span>(skytint * skycolour + cloudcolour, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="built_in">clamp</span>(f, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">	fragColor = <span class="type">vec4</span>( result, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码的效果如下图：</p>
<img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/Cloud.gif" alt="Cloud" style="zoom:50%;" / loading='lazy'>

<h4 id="山脉"><a href="#山脉" class="headerlink" title="山脉"></a>山脉</h4><p>使用噪声作为高度图</p>
<p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_heightMap.png" alt="noise_heightMap" loading='lazy'></p>
<h4 id="水面"><a href="#水面" class="headerlink" title="水面"></a>水面</h4><p>使用噪声纹理作为高度图，不断修改水面的法线方向，使用和时间相关的变量对噪声纹理采样，得到水流动的效果；</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>noise的其它应用如生成细胞形态，皮革纹理，烟雾，大理石，布料，道路等，基本思想都是基于噪声贴图，使用噪声图作为基本纹理进行处理，如color mapping，height mapping, normal mapping等</p>
<h3 id="noise-的相关库"><a href="#noise-的相关库" class="headerlink" title="noise 的相关库"></a>noise 的相关库</h3><ul>
<li><a target="_blank" rel="noopener" href="http://libnoise.sourceforge.net/index.html">libnoise</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903862298476557">WebGL进阶——走进图形噪声</a></li>
</ol>
<p>2.<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/ldscWj">https://www.shadertoy.com/view/ldscWj</a></p>
<p>3.<a target="_blank" rel="noopener" href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></p>
<ol start="4">
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50418658">使用笔、和代码”生成“火焰</a></li>
</ol>
<p>5.<a target="_blank" rel="noopener" href="https://www.cnblogs.com/leoin2012/p/7218033.html">[一篇文章搞懂柏林噪声算法]</a></p>
<p>6.<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341673601">几种常见的程序化噪声纹理</a></p>
<p>7.<a target="_blank" rel="noopener" href="https://blog.csdn.net/linjf520/article/details/100005528">Unity Shader - Noise 噪点图 - 实现简单山脉</a></p>
<p>8.<a target="_blank" rel="noopener" href="https://www.nvidia.fr/docs/IO/8343/RealTime-Procedural-Effects.pdf">Real-Time Procedural Effects</a></p>
<p>9.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a></p>
<p>10.<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/267016?utm_source=related_read&utm_medium=article&utm_term=related_read">如何使用噪声生成复杂的纹理？</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/shader/">shader</a></div><div class="post-share"><div class="social-share" data-image="/covers/24.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/09/04/%E8%BE%93%E5%87%BA%E7%BA%B9%E7%90%86%E4%B8%BAYUV%E5%92%8CRGB/" title="输出纹理为YUV和RGB"><img class="cover" src="/covers/3.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">输出纹理为YUV和RGB</div></div><div class="info-2"><div class="info-item-1">记录一个使用OpenGL ES在ios上渲染不正确的问题</div></div></div></a><a class="pagination-related" href="/2021/08/22/C-%E5%9F%BA%E7%A1%80/" title="C++基础"><img class="cover" src="/covers/10.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++基础</div></div><div class="info-2"><div class="info-item-1">C++基础知识合集记录</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/05/14/shader%E4%BB%8B%E7%BB%8D/" title="shader介绍"><img class="cover" src="/covers/25.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-14</div><div class="info-item-2">shader介绍</div></div><div class="info-2"><div class="info-item-1">shader基本用法总结  1. Shader 基本介绍首先需要认识到的一点是，shader是运行在GPU上的，天然的并行处理  我们通过编写代码(即shader），来‘点亮’下面画布中的每个像素！  右边列出这么长的公式不是为了劝退大家，它都是由基本图形公式组合而来（后面我会给大家进行讲解），理解了就容易，但是一下子放在这里就很难理解，所以大家在写shader复合效果代码时，一定要写注释说明，不然后面优化维护的同学是真的难受😭 12345678910111213141516171819202122void mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // create 100x100 cell sheet    float c = floor(100.0*(0.5+(fragCoord.x-0.5*iResolution.x)/iResolution.y));    float r = floor(100.0*(1.0-fragCoord.y/iResolution.y));    // paint ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">why join the navy if you can be a pirate</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Noise%E5%99%AA%E5%A3%B0"><span class="toc-text">Noise噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%99%AA%E5%A3%B0"><span class="toc-text">什么是噪声</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">噪声的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Perlin-Noise"><span class="toc-text">Perlin Noise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Perlin%E5%99%AA%E5%A3%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Perlin噪声的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Value-Noise"><span class="toc-text">Value Noise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81"><span class="toc-text">主要代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simplex-Noise"><span class="toc-text">Simplex Noise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81-1"><span class="toc-text">主要代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wavelet-Noise"><span class="toc-text">Wavelet Noise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worley-Noise"><span class="toc-text">Worley Noise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FBM"><span class="toc-text">FBM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E5%8F%A0%E5%8A%A0%EF%BC%8C%E6%AF%8F%E5%B1%82noise%E6%B7%BB%E5%8A%A0%E4%BD%8D%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC"><span class="toc-text">多层叠加，每层noise添加位移和旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E7%BF%98%E6%9B%B2"><span class="toc-text">域翘曲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%B9%B3%E5%9F%94%E7%9A%84%E5%99%AA%E5%A3%B0"><span class="toc-text">可平埔的噪声</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Curl-Noise"><span class="toc-text">Curl Noise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noise-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">noise 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91"><span class="toc-text">云</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%B1%E8%84%89"><span class="toc-text">山脉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E9%9D%A2"><span class="toc-text">水面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noise-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%BA%93"><span class="toc-text">noise 的相关库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/16/30.Python%E5%9F%BA%E7%A1%80%E5%8E%86%E7%BB%83/" title="python基础历练"><img src="/covers/30.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python基础历练"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/16/30.Python%E5%9F%BA%E7%A1%80%E5%8E%86%E7%BB%83/" title="python基础历练">python基础历练</a><time datetime="2026-01-16T08:10:43.000Z" title="发表于 2026-01-16 16:10:43">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/14/29-Vibe-Coding/" title="Vibe Coding 相关"><img src="/covers/29.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vibe Coding 相关"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/14/29-Vibe-Coding/" title="Vibe Coding 相关">Vibe Coding 相关</a><time datetime="2026-01-14T08:10:43.000Z" title="发表于 2026-01-14 16:10:43">2026-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/28.%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="大模型基本知识"><img src="/covers/28.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型基本知识"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/12/30/28.%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="大模型基本知识">大模型基本知识</a><time datetime="2025-12-30T13:01:18.000Z" title="发表于 2025-12-30 21:01:18">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/11/27.Agent/" title="Agent"><img src="/covers/27.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Agent"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/12/11/27.Agent/" title="Agent">Agent</a><time datetime="2025-12-11T13:01:18.000Z" title="发表于 2025-12-11 21:01:18">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/09/mobile-agent/" title="mobile-agent"><img src="/covers/21.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mobile-agent"/ loading='lazy'></a><div class="content"><a class="title" href="/2025/12/09/mobile-agent/" title="mobile-agent">mobile-agent</a><time datetime="2025-12-09T02:10:52.000Z" title="发表于 2025-12-09 10:10:52">2025-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>