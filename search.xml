<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2026/01/15/30.Python%E5%9F%BA%E7%A1%80%E5%8E%86%E7%BB%83/"/>
      <url>/2026/01/15/30.Python%E5%9F%BA%E7%A1%80%E5%8E%86%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><blockquote><p>具体的项目实践可参考：<a href="https://github.com/agentscope-ai/agentscope">AgentScope</a> 中的 src&#x2F;agentscope&#x2F;agent&#x2F;_agent_meta.py文件</p></blockquote><p>元类(Metaclass)是<strong>用来”创建类”的类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类 ---&gt; 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元类 ---&gt; 类 ---&gt; 对象</span></span><br></pre></td></tr></table></figure><p>元类的作用，主要用于在”类创建阶段”做事情，常见用途：</p><ol><li>自动修改类：</li></ol><ul><li>自动给类添加属性</li><li>自动给方法打日志</li><li>统一规范(如方法必须以do_开头)</li></ul><ol start="2"><li>注册&#x2F;收集类：</li></ol><ul><li>子类自动注册到某个地方  (<a href="https://github.com/agentscope-ai/agentscope">AgentScope</a> 就是用来做这个的)</li><li>常用于工厂模式、插件系统</li></ul><p>最基本的元类结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mls, name, bases, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;创建类：<span class="subst">&#123;name&#125;</span>)</span></span><br><span class="line"><span class="string">        return super().__new__(mls, name, bases, attrs)</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 参数说明</span></span><br><span class="line"><span class="string">mls:元类本身</span></span><br><span class="line"><span class="string">name: 类名</span></span><br><span class="line"><span class="string">bases: 父类</span></span><br><span class="line"><span class="string">attrs: 类属性字典 (注意也是包含函数的哦！)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vibe Coding 相关</title>
      <link href="/2026/01/14/29-Vibe-Coding/"/>
      <url>/2026/01/14/29-Vibe-Coding/</url>
      
        <content type="html"><![CDATA[<h3 id="Cursor使用"><a href="#Cursor使用" class="headerlink" title="Cursor使用"></a>Cursor使用</h3><blockquote><p>参考cursor官方文档：<a href="https://cursor.com/cn/docs">https://cursor.com/cn/docs</a></p></blockquote><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>规则的工作原理：规则在提示级别提供持久、可重用的上下文。应用后，规则内容会被加入到模型上下文的开头。这为 AI 在生成代码、理解编辑或协助处理工作流时提供一致的指导。</p><p>cursor提供了四种规则：项目规则、用户规则、团队规则、AGENTS.MD</p><h5 id="项目规则"><a href="#项目规则" class="headerlink" title="项目规则"></a>项目规则</h5><p>项目规则以 markdown 文件形式存放在 <code>.cursor/rules</code> 中，并纳入版本控制。规则可以通过路径模式限定作用范围，主要有以下的作用：</p><ul><li>沉淀与你代码库相关的领域知识</li><li>自动化项目特定的工作流或模板</li><li>统一风格或架构决策</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.cursor/rules/</span><br><span class="line">  react-patterns.mdc       <span class="comment"># 带前置元数据的规则(描述、globs)</span></span><br><span class="line">  api-guidelines.md        <span class="comment"># 简单 markdown 规则</span></span><br><span class="line">  frontend/                <span class="comment"># 在文件夹中组织规则</span></span><br><span class="line">    components.md</span><br></pre></td></tr></table></figure><p>而对于每个markdown的内容，如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">description: &quot;This rule provides standards for frontend components and API validation&quot;</span><br><span class="line"><span class="section">alwaysApply: false</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">...rest of the rule content</span><br></pre></td></tr></table></figure><h5 id="用户规则"><a href="#用户规则" class="headerlink" title="用户规则"></a>用户规则</h5><p>应用于全局的，将在所有项目上应用，这个在settings –&gt; Rules 里面，如下面的例子：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20260116180357582.png" alt="image-20260116180357582"></p><p>可以看到，因为我设置了这个规则，我和cursor交互时(chat时候)，返回给我的都是中文回复；</p><h5 id="AGENTS-MD"><a href="#AGENTS-MD" class="headerlink" title="AGENTS.MD"></a>AGENTS.MD</h5><p><code>AGENTS.md</code> 是一个用于定义 agent 指令的简单 markdown 文件。将它放在项目根目录中，作为 <code>.cursor/rules</code> 的替代选项，适用于简单直接的用例。<strong><code>AGENTS.md</code> 是一个没有元数据或复杂配置的纯 markdown 文件。对于只需要简单、易读指令</strong>，而不想引入结构化规则额外负担的项目来说，它是理想选择。</p><p>官方的一个简单例子如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Project Instructions</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Code Style</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Use TypeScript for all new files</span><br><span class="line"><span class="bullet">-</span> Prefer functional components in React</span><br><span class="line"><span class="bullet">-</span> Use snake<span class="emphasis">_case for database columns</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## Architecture</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- Follow the repository pattern</span></span><br><span class="line"><span class="emphasis">- Keep business logic in service layers</span></span><br></pre></td></tr></table></figure><p>当然也是支持嵌套的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">  AGENTS.md              <span class="comment"># 全局指令</span></span><br><span class="line">  frontend/</span><br><span class="line">    AGENTS.md            <span class="comment"># 前端专用指令</span></span><br><span class="line">    components/</span><br><span class="line">      AGENTS.md          <span class="comment"># 组件专用指令</span></span><br><span class="line">  backend/</span><br><span class="line">    AGENTS.md            <span class="comment"># 后端专用指令</span></span><br></pre></td></tr></table></figure><h4 id="skills-支持"><a href="#skills-支持" class="headerlink" title="skills 支持"></a>skills 支持</h4><p>技能何时工作？Cursor 启动时会自动从技能目录中发现技能，并将它们提供给 Agent。Agent 会查看可用的技能，并根据上下文决定何时使用。</p><h5 id="技能加载目录"><a href="#技能加载目录" class="headerlink" title="技能加载目录"></a>技能加载目录</h5><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20260116181303076.png" alt="image-20260116181303076"></p><p>每个技能都应是一个包含 <code>SKILL.md</code> 文件的文件夹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.cursor/</span><br><span class="line">└── skills/</span><br><span class="line">    └── my-skill/</span><br><span class="line">        └── SKILL.md</span><br></pre></td></tr></table></figure><p>关于SKILL.md的格式，下面是一个简单的例子,当然在my-skill文件夹可以添加一些资源，脚本等等文件夹，这个可以查看claude的标准来创建自己的skills</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">name: my-skill</span><br><span class="line"><span class="section">description: Short description of what this skill does and when to use it.</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section"># My Skill</span></span><br><span class="line"></span><br><span class="line">Detailed instructions for the agent.</span><br><span class="line"></span><br><span class="line"><span class="section">## When to Use</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Use this skill when...</span><br><span class="line"><span class="bullet">-</span> This skill is helpful for...</span><br><span class="line"></span><br><span class="line"><span class="section">## Instructions</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Step-by-step guidance for the agent</span><br><span class="line"><span class="bullet">-</span> Domain-specific conventions</span><br><span class="line"><span class="bullet">-</span> Best practices and patterns</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/1993009461451831150">认知重建：Speckit 用了三个月，我放弃了——走出工具很强但用不好的困境</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大模型基本知识</title>
      <link href="/2025/12/30/28.%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/12/30/28.%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://mp.weixin.qq.com/s/wcjYPzPq-lADvz-TeKZ7VQ">教你从零“手搓”一个大模型，别再只会调用API了</a></li><li><a href="https://github.com/GiovanniPasq/agentic-rag-for-dummies">简单的Agentic-RAG流程</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Agent</title>
      <link href="/2025/12/11/27.Agent/"/>
      <url>/2025/12/11/27.Agent/</url>
      
        <content type="html"><![CDATA[<h3 id="Youtu-LLM-2B-26-01-06"><a href="#Youtu-LLM-2B-26-01-06" class="headerlink" title="Youtu-LLM-2B (26.01.06)"></a>Youtu-LLM-2B (26.01.06)</h3><blockquote><p>仓库地址：<a href="https://modelscope.cn/models/Tencent-YouTu-Research/Youtu-LLM-2B">https://modelscope.cn/models/Tencent-YouTu-Research/Youtu-LLM-2B</a></p><p>特点：端侧Agent模型，此外在tokenizer这一步也进行了优化()</p></blockquote><p>看了一下paper，paper中提到了数据构建的过程，主要按照下面的结构去构建</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20260107112806007.png" alt="image-20260107112806007"></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20260107112826767.png" alt="image-20260107112826767"></p><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><h4 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h4><ol><li><a href="https://github.com/datawhalechina/hello-agents">https://github.com/datawhalechina/hello-agents</a></li><li><a href="https://github.com/huggingface/agents-course">https://github.com/huggingface/agents-course</a></li></ol><h4 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h4><ol><li><a href="https://github.com/NirDiamant/GenAI_Agents">https://github.com/NirDiamant/GenAI_Agents</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><h4 id="Multi-Agent"><a href="#Multi-Agent" class="headerlink" title="Multi-Agent"></a>Multi-Agent</h4><ol><li><a href="https://www.blog.langchain.com/choosing-the-right-multi-agent-architecture/">Choosing the Right Multi-Agent Architecture</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mobile-agent</title>
      <link href="/2025/12/09/mobile-agent/"/>
      <url>/2025/12/09/mobile-agent/</url>
      
        <content type="html"><![CDATA[<h3 id="AgentCPM"><a href="#AgentCPM" class="headerlink" title="AgentCPM"></a>AgentCPM</h3><blockquote><p><a href="https://github.com/OpenBMB/AgentCPM">https://github.com/OpenBMB/AgentCPM</a></p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/X-PLUG/MobileAgent">MobileAgent</a></li><li><a href="https://github.com/zai-org/Open-AutoGLM">Open-AutoGLM</a></li><li><a href="https://mp.weixin.qq.com/s/6YqU1eHGE6YmNitUkzuYPw">A2UI - 智能体自动生成 UI 界面的全新协议</a></li><li><a href="https://modelscope.cn/models/Tongyi-MAI/MAI-UI-8B">MAI-UI：面向真实世界的通用 GUI 智能体</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> 端侧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Agent是如何做Plan的？</title>
      <link href="/2025/12/08/LLM%E7%9A%84plan%E8%B0%83%E7%A0%94/"/>
      <url>/2025/12/08/LLM%E7%9A%84plan%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h3 id="1-langchain-langgraph"><a href="#1-langchain-langgraph" class="headerlink" title="1. langchain&#x2F;langgraph"></a>1. langchain&#x2F;langgraph</h3><blockquote><p>参考资料：</p><ol><li><a href="https://docs.langchain.com/oss/python/langchain/middleware/built-in#to-do-list">https://docs.langchain.com/oss/python/langchain/middleware/built-in#to-do-list</a></li></ol></blockquote><p>langchain的思想是通过middleware的形式来添加plan的能力，可以参考源码部分：langchain&#x2F;libs&#x2F;langchain_v1&#x2F;langchain&#x2F;agents&#x2F;middleware&#x2F;todo.py （12月8日，后续不知道会不会变化）<strong>其本质仍然是一个工具函数的调用，内部的一个工具是write_todos</strong>, 相关的middleware是 TodoListMiddleware</p><p>这个工具的具体定义是：关于write_todos这个工具的描述，这个描述写的很长，具体可以去源码查看；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tool(<span class="params">description=WRITE_TODOS_TOOL_DESCRIPTION</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_todos</span>(<span class="params">todos: <span class="built_in">list</span>[Todo], tool_call_id: Annotated[<span class="built_in">str</span>, InjectedToolCallId]</span>) -&gt; Command:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create and manage a structured task list for your current work session.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Command(</span><br><span class="line">        update=&#123;</span><br><span class="line">            <span class="string">&quot;todos&quot;</span>: todos,</span><br><span class="line">            <span class="string">&quot;messages&quot;</span>: [ToolMessage(<span class="string">f&quot;Updated todo list to <span class="subst">&#123;todos&#125;</span>&quot;</span>, tool_call_id=tool_call_id)],</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>system prompt是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WRITE_TODOS_SYSTEM_PROMPT = <span class="string">&quot;&quot;&quot;## `write_todos`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You have access to the `write_todos` tool to help you manage and plan complex objectives.</span></span><br><span class="line"><span class="string">Use this tool for complex objectives to ensure that you are tracking each necessary step and giving the user visibility into your progress.</span></span><br><span class="line"><span class="string">This tool is very helpful for planning complex objectives, and for breaking down these larger complex objectives into smaller steps.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is critical that you mark todos as completed as soon as you are done with a step. Do not batch up multiple steps before marking them as completed.</span></span><br><span class="line"><span class="string">For simple objectives that only require a few steps, it is better to just complete the objective directly and NOT use this tool.</span></span><br><span class="line"><span class="string">Writing todos takes time and tokens, use it when it is helpful for managing complex many-step problems! But not for simple few-step requests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Important To-Do List Usage Notes to Remember</span></span><br><span class="line"><span class="string">- The `write_todos` tool should never be called multiple times in parallel.</span></span><br><span class="line"><span class="string">- Don&#x27;t be afraid to revise the To-Do list as you go. New information may reveal new tasks that need to be done, or old tasks that are irrelevant.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-Qwen-code"><a href="#2-Qwen-code" class="headerlink" title="2. Qwen code"></a>2. Qwen code</h3><blockquote><p><a href="https://github.com/QwenLM/qwen-code">https://github.com/QwenLM/qwen-code</a></p></blockquote><p>采用的是内置工具的方式来实现agent的plan能力，源代码部分可参考：qwen-code&#x2F;packages&#x2F;core&#x2F;src&#x2F;tools&#x2F;todoWrite.ts</p><p>具体的提供了下面的todo工具类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TodoWriteToolInvocation</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseToolInvocation</span>&lt;</span><br><span class="line">  <span class="title class_">TodoWriteParams</span>,</span><br><span class="line">  <span class="title class_">ToolResult</span></span><br><span class="line">&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露给外面的todo工具类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TodoWriteTool</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseDeclarativeTool</span>&lt;</span><br><span class="line">  <span class="title class_">TodoWriteParams</span>,</span><br><span class="line">  <span class="title class_">ToolResult</span></span><br><span class="line">&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>关于工具的描述，截取一部分prompt如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoWriteToolDescription = <span class="string">`</span></span><br><span class="line"><span class="string">Use this tool to create and manage a structured task list for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.</span></span><br><span class="line"><span class="string">It also helps the user understand the progress of the task and overall progress of their requests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## When to Use This Tool</span></span><br><span class="line"><span class="string">Use this tool proactively in these scenarios:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Complex multi-step tasks - When a task requires 3 or more distinct steps or actions</span></span><br><span class="line"><span class="string">2. Non-trivial and complex tasks - Tasks that require careful planning or multiple operations</span></span><br><span class="line"><span class="string">3. User explicitly requests todo list - When the user directly asks you to use the todo list</span></span><br><span class="line"><span class="string">4. User provides multiple tasks - When users provide a list of things to be done (numbered or comma-separated)</span></span><br><span class="line"><span class="string">5. After receiving new instructions - Immediately capture user requirements as todos</span></span><br><span class="line"><span class="string">6. When you start working on a task - Mark it as in_progress BEFORE beginning work. Ideally you should only have one todo as in_progress at a time</span></span><br><span class="line"><span class="string">7. After completing a task - Mark it as completed and add any new follow-up tasks discovered during implementation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## When NOT to Use This Tool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Skip using this tool when:</span></span><br><span class="line"><span class="string">1. There is only a single, straightforward task</span></span><br><span class="line"><span class="string">2. The task is trivial and tracking it provides no organizational benefit</span></span><br><span class="line"><span class="string">3. The task can be completed in less than 3 trivial steps</span></span><br><span class="line"><span class="string">4. The task is purely conversational or informational</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NOTE that you should not use this tool if there is only one trivial task to do. In this case you are better off just doing the task directly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Examples of When to Use the Todo List </span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-gemini-cli"><a href="#3-gemini-cli" class="headerlink" title="3. gemini cli"></a>3. gemini cli</h3><p>和qwen code 类似，源码部分在：gemini-cli&#x2F;packages&#x2F;core&#x2F;src&#x2F;tools&#x2F;write-todos.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">WriteTodosTool</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseDeclarativeTool</span>&lt;</span><br><span class="line">  <span class="title class_">WriteTodosToolParams</span>,</span><br><span class="line">  <span class="title class_">ToolResult</span></span><br><span class="line">&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>工具说明的prompt截取如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">WRITE_TODOS_DESCRIPTION</span> = <span class="string">`This tool can help you list out the current subtasks that are required to be completed for a given user request. The list of subtasks helps you keep track of the current task, organize complex queries and help ensure that you don&#x27;t miss any steps. With this list, the user can also see the current progress you are making in executing a given task.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Depending on the task complexity, you should first divide a given task into subtasks and then use this tool to list out the subtasks that are required to be completed for a given user request.</span></span><br><span class="line"><span class="string">Each of the subtasks should be clear and distinct. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use this tool for complex queries that require multiple steps. If you find that the request is actually complex after you have started executing the user task, create a todo list and use it. If execution of the user task requires multiple steps, planning and generally is higher complexity than a simple Q&amp;A, use this tool.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DO NOT use this tool for simple tasks that can be completed in less than 2 steps. If the user query is simple and straightforward, do not use the tool. If you can respond with an answer in a single turn then this tool is not required.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Task state definitions</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- pending: Work has not begun on a given subtask.</span></span><br><span class="line"><span class="string">- in_progress: Marked just prior to beginning work on a given subtask. You should only have one subtask as in_progress at a time.</span></span><br><span class="line"><span class="string">- completed: Subtask was successfully completed with no errors or issues. If the subtask required more steps to complete, update the todo list with the subtasks. All steps should be identified as completed only when they are completed.</span></span><br><span class="line"><span class="string">- cancelled: As you update the todo list, some tasks are not required anymore due to the dynamic nature of the task. In this case, mark the subtasks as cancelled.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Methodology for using this tool</span></span><br><span class="line"><span class="string">1. Use this todo list as soon as you receive a user request based on the complexity of the task.</span></span><br><span class="line"><span class="string">2. Keep track of every subtask that you update the list with.</span></span><br><span class="line"><span class="string">3. Mark a subtask as in_progress before you begin working on it. You should only have one subtask as in_progress at a time.</span></span><br><span class="line"><span class="string">4. Update the subtask list as you proceed in executing the task. The subtask list is not static and should reflect your progress and current plans, which may evolve as you acquire new information.</span></span><br><span class="line"><span class="string">5. Mark a subtask as completed when you have completed it.</span></span><br><span class="line"><span class="string">6. Mark a subtask as cancelled if the subtask is no longer needed.</span></span><br><span class="line"><span class="string">7. You must update the todo list as soon as you start, stop or cancel a subtask. Don&#x27;t batch or wait to update the todo list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Examples of When to Use the Todo List</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><h3 id="4-AgentScope"><a href="#4-AgentScope" class="headerlink" title="4. AgentScope"></a>4. AgentScope</h3><blockquote><p><a href="https://github.com/agentscope-ai/agentscope">https://github.com/agentscope-ai/agentscope</a></p></blockquote><p>也是通过工具调用的方式来实现的，可以参考我之前的文档 <a href="https://flippy-bird.github.io/2025/11/25/AgentScope%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">AgentScope源码学习</a></p><h3 id="5-cline"><a href="#5-cline" class="headerlink" title="5.cline"></a>5.cline</h3><blockquote><p><a href="https://github.com/cline/cline">https://github.com/cline/cline</a></p></blockquote><p>应该也是通过调用的工具的方式让Agent具备了plan的能力，相关的提示词源码是：<a href="https://github.com/cline/cline/blob/main/src/core/prompts/system-prompt/components/task_progress.ts">cline&#x2F;src&#x2F;core&#x2F;prompts&#x2F;system-prompt&#x2F;components&#x2F;task_progress.ts</a></p><p>对应的prompt如下：可以看到，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">UPDATING_TASK_PROGRESS</span> = <span class="string">`UPDATING TASK PROGRESS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can track and communicate your progress on the overall task using the task_progress parameter supported by every tool call. Using task_progress ensures you remain on task, and stay focused on completing the user&#x27;s objective. This parameter can be used in any mode, and with any tool call.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- When switching from PLAN MODE to ACT MODE, you must create a comprehensive todo list for the task using the task_progress parameter</span></span><br><span class="line"><span class="string">- Todo list updates should be done silently using the task_progress parameter - do not announce these updates to the user</span></span><br><span class="line"><span class="string">- Use standard Markdown checklist format: &quot;- [ ]&quot; for incomplete items and &quot;- [x]&quot; for completed items</span></span><br><span class="line"><span class="string">- Keep items focused on meaningful progress milestones rather than minor technical details. The checklist should not be so granular that minor implementation details clutter the progress tracking.</span></span><br><span class="line"><span class="string">- For simple tasks, short checklists with even a single item are acceptable. For complex tasks, avoid making the checklist too long or verbose.</span></span><br><span class="line"><span class="string">- If you are creating this checklist for the first time, and the tool use completes the first step in the checklist, make sure to mark it as completed in your task_progress parameter.</span></span><br><span class="line"><span class="string">- Provide the whole checklist of steps you intend to complete in the task, and keep the checkboxes updated as you make progress. It&#x27;s okay to rewrite this checklist as needed if it becomes invalid due to scope changes or new information.</span></span><br><span class="line"><span class="string">- If a checklist is being used, be sure to update it any time a step has been completed.</span></span><br><span class="line"><span class="string">- The system will automatically include todo list context in your prompts when appropriate - these reminders are important.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string">&lt;execute_command&gt;</span></span><br><span class="line"><span class="string">&lt;command&gt;npm install react&lt;/command&gt;</span></span><br><span class="line"><span class="string">&lt;requires_approval&gt;false&lt;/requires_approval&gt;</span></span><br><span class="line"><span class="string">&lt;task_progress&gt;</span></span><br><span class="line"><span class="string">- [x] Set up project structure</span></span><br><span class="line"><span class="string">- [x] Install dependencies</span></span><br><span class="line"><span class="string">- [ ] Create components</span></span><br><span class="line"><span class="string">- [ ] Test application</span></span><br><span class="line"><span class="string">&lt;/task_progress&gt;</span></span><br><span class="line"><span class="string">&lt;/execute_command&gt;`</span></span><br></pre></td></tr></table></figure><p>对于Vscode中ide部分，貌似是通过一个focus chain模块来实现的，具体部分可参考源代码文件：</p><ul><li>cline&#x2F;src&#x2F;core&#x2F;task&#x2F;focus-chain&#x2F;</li><li>cline&#x2F;src&#x2F;shared&#x2F;tools.ts</li></ul><p>cline&#x2F;src&#x2F;shared&#x2F;tools.ts里面是cline的默认工具，其中 TODO指向的是focus_chain 这个工具</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> <span class="title class_">ClineDefaultTool</span> &#123;</span><br><span class="line"><span class="variable constant_">ASK</span> = <span class="string">&quot;ask_followup_question&quot;</span>,</span><br><span class="line"><span class="variable constant_">ATTEMPT</span> = <span class="string">&quot;attempt_completion&quot;</span>,</span><br><span class="line"><span class="variable constant_">BASH</span> = <span class="string">&quot;execute_command&quot;</span>,</span><br><span class="line"><span class="variable constant_">FILE_EDIT</span> = <span class="string">&quot;replace_in_file&quot;</span>,</span><br><span class="line"><span class="variable constant_">FILE_READ</span> = <span class="string">&quot;read_file&quot;</span>,</span><br><span class="line"><span class="variable constant_">FILE_NEW</span> = <span class="string">&quot;write_to_file&quot;</span>,</span><br><span class="line"><span class="variable constant_">SEARCH</span> = <span class="string">&quot;search_files&quot;</span>,</span><br><span class="line"><span class="variable constant_">LIST_FILES</span> = <span class="string">&quot;list_files&quot;</span>,</span><br><span class="line"><span class="variable constant_">LIST_CODE_DEF</span> = <span class="string">&quot;list_code_definition_names&quot;</span>,</span><br><span class="line"><span class="variable constant_">BROWSER</span> = <span class="string">&quot;browser_action&quot;</span>,</span><br><span class="line"><span class="variable constant_">MCP_USE</span> = <span class="string">&quot;use_mcp_tool&quot;</span>,</span><br><span class="line"><span class="variable constant_">MCP_ACCESS</span> = <span class="string">&quot;access_mcp_resource&quot;</span>,</span><br><span class="line"><span class="variable constant_">MCP_DOCS</span> = <span class="string">&quot;load_mcp_documentation&quot;</span>,</span><br><span class="line"><span class="variable constant_">NEW_TASK</span> = <span class="string">&quot;new_task&quot;</span>,</span><br><span class="line"><span class="variable constant_">PLAN_MODE</span> = <span class="string">&quot;plan_mode_respond&quot;</span>,</span><br><span class="line"><span class="variable constant_">ACT_MODE</span> = <span class="string">&quot;act_mode_respond&quot;</span>,</span><br><span class="line"><span class="variable constant_">TODO</span> = <span class="string">&quot;focus_chain&quot;</span>,      <span class="comment">// 这个地方，应该就是cline里面用来规划的工具了</span></span><br><span class="line"><span class="variable constant_">WEB_FETCH</span> = <span class="string">&quot;web_fetch&quot;</span>,</span><br><span class="line"><span class="variable constant_">WEB_SEARCH</span> = <span class="string">&quot;web_search&quot;</span>,</span><br><span class="line"><span class="variable constant_">CONDENSE</span> = <span class="string">&quot;condense&quot;</span>,</span><br><span class="line"><span class="variable constant_">SUMMARIZE_TASK</span> = <span class="string">&quot;summarize_task&quot;</span>,</span><br><span class="line"><span class="variable constant_">REPORT_BUG</span> = <span class="string">&quot;report_bug&quot;</span>,</span><br><span class="line"><span class="variable constant_">NEW_RULE</span> = <span class="string">&quot;new_rule&quot;</span>,</span><br><span class="line"><span class="variable constant_">APPLY_PATCH</span> = <span class="string">&quot;apply_patch&quot;</span>,</span><br><span class="line"><span class="variable constant_">GENERATE_EXPLANATION</span> = <span class="string">&quot;generate_explanation&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再按照cline&#x2F;src&#x2F;core 里面的README的结构说明</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251209105250448.png" alt="image-20251209105250448"></p><p>工具类相关的实现应该是在task文件目录下，因此在task目录，可以找到focus-chain这个文件夹</p><p>在index.ts 文件里面可以看到，是通过FocusChainManager 这个类来实现todo list的检查和更新的；在prompts.ts这个文件夹里面可以看到涉及到todo list操作相关的prompt，下面展示一个初始化任务时的提示词</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prompt for initial list creation</span></span><br><span class="line"><span class="keyword">const</span> initial = <span class="string">`</span></span><br><span class="line"><span class="string"># task_progress CREATION REQUIRED - ACT MODE ACTIVATED</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**You&#x27;ve just switched from PLAN MODE to ACT MODE!**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** IMMEDIATE ACTION REQUIRED:**</span></span><br><span class="line"><span class="string">1. Create a comprehensive todo list in your NEXT tool call</span></span><br><span class="line"><span class="string">2. Use the task_progress parameter to provide the list</span></span><br><span class="line"><span class="string">3. Format each item using markdown checklist syntax:</span></span><br><span class="line"><span class="string">- [ ] For tasks to be done</span></span><br><span class="line"><span class="string">- [x] For any tasks already completed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Your todo/task_progress list should include:**</span></span><br><span class="line"><span class="string">   - All major implementation steps</span></span><br><span class="line"><span class="string">   - Testing and validation tasks</span></span><br><span class="line"><span class="string">   - Documentation updates if needed</span></span><br><span class="line"><span class="string">   - Final verification steps</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Example format:**\</span></span><br><span class="line"><span class="string">   - [ ] Set up project structure</span></span><br><span class="line"><span class="string">   - [ ] Implement core functionality</span></span><br><span class="line"><span class="string">   - [ ] Add error handling</span></span><br><span class="line"><span class="string">   - [ ] Write tests</span></span><br><span class="line"><span class="string">   - [ ] Test implementation</span></span><br><span class="line"><span class="string">   - [ ] Document changes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**Remember:** Keeping the task_progress list updated helps track progress and ensures nothing is missed.`</span></span><br></pre></td></tr></table></figure><p>从使用上来看，cline似乎也是使用的ReAct模式，当然，可能会有一些变化，核心逻辑是在 cline&#x2F;src&#x2F;core&#x2F;task&#x2F;index.ts这个文件里面，这个文件里面有一些循环,如下面的initiateTaskLoop函数，大概可以判断应该是存在ReAct模式的(从下面这个函数的注释也可以看出来)，逻辑太长，后面有时间可以仔细研究一下，主要看recursivelyMakeClineRequests的逻辑；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> <span class="title function_">initiateTaskLoop</span>(<span class="attr">userContent</span>: <span class="title class_">ClineContent</span>[]): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> nextUserContent = userContent</span><br><span class="line">    <span class="keyword">let</span> includeFileDetails = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="variable language_">this</span>.<span class="property">taskState</span>.<span class="property">abort</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> didEndLoop = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">recursivelyMakeClineRequests</span>(nextUserContent, includeFileDetails)</span><br><span class="line">        includeFileDetails = <span class="literal">false</span> <span class="comment">// we only need file details the first time</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  The way this agentic loop works is that cline will be given a task that he then calls tools to complete. unless there&#x27;s an attempt_completion call, we keep responding back to him with his tool&#x27;s responses until he either attempt_completion or does not use anymore tools. If he does not use anymore tools, we ask him to consider if he&#x27;s completed the task and then call attempt_completion, otherwise proceed with completing the task.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//const totalCost = this.calculateApiCost(totalInputTokens, totalOutputTokens)</span></span><br><span class="line">        <span class="keyword">if</span> (didEndLoop) &#123;</span><br><span class="line">            <span class="comment">// For now a task never &#x27;completes&#x27;. This will only happen if the user hits max requests and denies resetting the count.</span></span><br><span class="line">            <span class="comment">//this.say(&quot;task_completed&quot;, `Task completed. Total API usage cost: $&#123;totalCost&#125;`)</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// this.say(</span></span><br><span class="line">            <span class="comment">// &quot;tool&quot;,</span></span><br><span class="line">            <span class="comment">// &quot;Cline responded with only text blocks but has not called attempt_completion yet. Forcing him to continue with task...&quot;</span></span><br><span class="line">            <span class="comment">// )</span></span><br><span class="line">            nextUserContent = [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">text</span>: formatResponse.<span class="title function_">noToolsUsed</span>(<span class="variable language_">this</span>.<span class="property">useNativeToolCalls</span>),</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">taskState</span>.<span class="property">consecutiveMistakeCount</span>++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mem0源码学习</title>
      <link href="/2025/12/01/Mem0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/12/01/Mem0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/mem0ai/mem0">https://github.com/mem0ai/mem0</a></p></blockquote><h3 id="1-项目的核心代码"><a href="#1-项目的核心代码" class="headerlink" title="1. 项目的核心代码"></a>1. 项目的核心代码</h3><p>从memory&#x2F;base.py 里面的基类可以看到，记忆功能主要实现了下面的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBase</span>(<span class="title class_ inherited__">ABC</span>)</span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, memory_id</span>):  <span class="comment"># 根据id获取对应id的memory</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all</span>(<span class="params">self</span>):         <span class="comment"># 列出所有的memory</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, memory_id, data</span>):    <span class="comment"># 更新id的memory</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, memory_id</span>):   <span class="comment"># 删除id的memory</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">history</span>(<span class="params">self, memory_id</span>):  <span class="comment"># Get the history of changes for a memory by ID.</span></span><br></pre></td></tr></table></figure><p>mem0的核心实现在memory&#x2F;main.py 文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>(<span class="title class_ inherited__">MemoryBase</span>):</span><br><span class="line"><span class="comment"># 这里除了实现上面base定义的基本功能外，有一个search的核心功能实现</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, query, ...</span>):  <span class="comment"># 这里会根据用户的query去寻找最相关的memory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncMemory</span>(<span class="title class_ inherited__">MemoryBase</span>):  <span class="comment"># 异步的接口不用再使用另外一个基类，直接使用了MemoryBase，但是在实现时使用了异步</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, memory_id</span>):</span><br></pre></td></tr></table></figure><h4 id="1-1-search"><a href="#1-1-search" class="headerlink" title="1.1 search"></a>1.1 search</h4><p>看search里面的实现，就是标准的RAG流程，embedding query, 然后从向量数据库或者图数据库召回，做一个ReRank重排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是通过下面的函数来实现向量召回的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_search_vector_store</span>(<span class="params">self, query, filters, limit, threshold: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span>):</span><br><span class="line">    embeddings = <span class="variable language_">self</span>.embedding_model.embed(query, <span class="string">&quot;search&quot;</span>)</span><br><span class="line">    <span class="comment"># 这一步就是向量检索了</span></span><br><span class="line">    memories = <span class="variable language_">self</span>.vector_store.search(query=query, vectors=embeddings, limit=limit, filters=filters)</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, query, ...</span>):</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        future_memories = executor.submit(<span class="variable language_">self</span>._search_vector_store, query, effective_filters, limit, threshold)</span><br><span class="line">        <span class="comment">## 这里的self.graph就是图关系库</span></span><br><span class="line">        future_graph_entities = (executor.submit(<span class="variable language_">self</span>.graph.search, query, effective_filters, limit) <span class="keyword">if</span> <span class="variable language_">self</span>.enable_graph <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>关于Memory类中使用到的LLM，embedding, graph,rerank模型等等都是使用<strong>工厂模式</strong>来初始化的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>(<span class="title class_ inherited__">MemoryBase</span>):</span><br><span class="line">    <span class="variable language_">self</span>.embedding_model = EmbedderFactory.create(</span><br><span class="line">            <span class="variable language_">self</span>.config.embedder.provider,</span><br><span class="line">            <span class="variable language_">self</span>.config.embedder.config,</span><br><span class="line">            <span class="variable language_">self</span>.config.vector_store.config,</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>.vector_store = VectorStoreFactory.create(</span><br><span class="line">            <span class="variable language_">self</span>.config.vector_store.provider, <span class="variable language_">self</span>.config.vector_store.config</span><br><span class="line">        )</span><br><span class="line">    <span class="variable language_">self</span>.llm = LlmFactory.create(<span class="variable language_">self</span>.config.llm.provider, <span class="variable language_">self</span>.config.llm.config)</span><br><span class="line">    <span class="keyword">if</span> config.reranker:</span><br><span class="line">        <span class="variable language_">self</span>.reranker = RerankerFactory.create(</span><br><span class="line">            config.reranker.provider, </span><br><span class="line">            config.reranker.config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.config.graph_store.config:</span><br><span class="line">        provider = <span class="variable language_">self</span>.config.graph_store.provider</span><br><span class="line">        <span class="variable language_">self</span>.graph = GraphStoreFactory.create(provider, <span class="variable language_">self</span>.config)</span><br><span class="line">        <span class="variable language_">self</span>.enable_graph = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.graph = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>工厂函数里面对应的就是各个可以支持的实现，这个实现是在 mem0&#x2F;utils&#x2F;factory.py 文件中，下面的是图关系数据库的支持代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphStoreFactory</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Factory for creating MemoryGraph instances for different graph store providers.</span></span><br><span class="line"><span class="string">    Usage: GraphStoreFactory.create(provider_name, config)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    provider_to_class = &#123;</span><br><span class="line">        <span class="string">&quot;memgraph&quot;</span>: <span class="string">&quot;mem0.memory.memgraph_memory.MemoryGraph&quot;</span>,</span><br><span class="line">        <span class="string">&quot;neptune&quot;</span>: <span class="string">&quot;mem0.graphs.neptune.neptunegraph.MemoryGraph&quot;</span>,</span><br><span class="line">        <span class="string">&quot;neptunedb&quot;</span>: <span class="string">&quot;mem0.graphs.neptune.neptunedb.MemoryGraph&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kuzu&quot;</span>: <span class="string">&quot;mem0.memory.kuzu_memory.MemoryGraph&quot;</span>,</span><br><span class="line">        <span class="string">&quot;default&quot;</span>: <span class="string">&quot;mem0.memory.graph_memory.MemoryGraph&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">cls, provider_name, config</span>):</span><br><span class="line">        class_type = cls.provider_to_class.get(provider_name, cls.provider_to_class[<span class="string">&quot;default&quot;</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            GraphClass = load_class(class_type)</span><br><span class="line">        <span class="keyword">except</span> (ImportError, AttributeError) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> ImportError(<span class="string">f&quot;Could not import MemoryGraph for provider &#x27;<span class="subst">&#123;provider_name&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> GraphClass(config)</span><br></pre></td></tr></table></figure><p>可以看到mem0支持4中图关系数据库memgraph、neptune、neptunedb、kuzu(为什么会放在两个不同文件夹下面呢？这个暂时还没看明白)，其它的LLM，embedding等等类似；</p><h4 id="1-2-add"><a href="#1-2-add" class="headerlink" title="1.2 add"></a>1.2 add</h4><p>这个函数是mem0的核心,主要通过两个子函数来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">        messages,</span></span><br><span class="line"><span class="params">        *,</span></span><br><span class="line"><span class="params">        user_id: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        agent_id: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        run_id: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        metadata: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        infer: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        memory_type: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        prompt: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span>):</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 处理embedding相关的</span></span><br><span class="line">        future1 = executor.submit(<span class="variable language_">self</span>._add_to_vector_store, messages, processed_metadata, effective_filters, infer)</span><br><span class="line">        <span class="comment"># 图关系数据库  </span></span><br><span class="line">        future2 = executor.submit(<span class="variable language_">self</span>._add_to_graph, messages, effective_filters)</span><br><span class="line"></span><br><span class="line">        concurrent.futures.wait([future1, future2])</span><br><span class="line"></span><br><span class="line">        vector_store_result = future1.result()</span><br><span class="line">        graph_result = future2.result()</span><br></pre></td></tr></table></figure><p>而核心中的核心是_add_to_vector_store 这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 infer 为false时，是常规的记忆存储，embedding,入库 (直接入库的模式)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_add_to_vector_store</span>(<span class="params">self, messages, metadata, filters, infer</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当infer 为true时，将会使用LLM分析对话内容，提取有意义的事实，并智能地决定如何处理这些记忆（添加、更新、删除或保持不变）</span></span><br><span class="line">    <span class="comment">### 这里是提取实体关系的逻辑</span></span><br><span class="line">    parsed_messages = parse_messages(messages)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.config.custom_fact_extraction_prompt:</span><br><span class="line">        system_prompt = <span class="variable language_">self</span>.config.custom_fact_extraction_prompt</span><br><span class="line">        user_prompt = <span class="string">f&quot;Input:\n<span class="subst">&#123;parsed_messages&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Determine if this should use agent memory extraction based on agent_id presence</span></span><br><span class="line">        <span class="comment"># and role types in messages</span></span><br><span class="line">        is_agent_memory = <span class="variable language_">self</span>._should_use_agent_memory_extraction(messages, metadata)</span><br><span class="line">        system_prompt, user_prompt = get_fact_retrieval_messages(parsed_messages, is_agent_memory)</span><br><span class="line"></span><br><span class="line">    response = <span class="variable language_">self</span>.llm.generate_response(</span><br><span class="line">        messages=[</span><br><span class="line">            &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_prompt&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_prompt&#125;,</span><br><span class="line">        ],</span><br><span class="line">        response_format=&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;json_object&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抽取实体后，开始进行判断下一步对记忆进行 增删改查的逻辑了，也是借助了大模型来实现</span></span><br><span class="line">    <span class="comment"># 这部分太长省略了</span></span><br></pre></td></tr></table></figure><p>可以观察一下mem0中抽取用户或者Agent 特性的提示词 (太长，只展示一部分，具体文件在：mem0&#x2F;configs&#x2F;prompts.py 里面的USER_MEMORY_EXTRACTION_PROMPT和AGENT_MEMORY_EXTRACTION_PROMPT)</p><p>首先，LLM主要任务是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AGENT_MEMORY_EXTRACTION_PROMPT = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You are a Personal Information Organizer, specialized in accurately storing facts, user memories, and preferences. </span></span><br><span class="line"><span class="string">Your primary role is to extract relevant pieces of information from conversations and organize them into distinct, manageable facts. </span></span><br><span class="line"><span class="string">This allows for easy retrieval and personalization in future interactions. Below are the types of information you need to focus on and the detailed instructions on how to handle the input data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># [IMPORTANT]: GENERATE FACTS SOLELY BASED ON THE USER&#x27;S MESSAGES. DO NOT INCLUDE INFORMATION FROM ASSISTANT OR SYSTEM MESSAGES.</span></span><br><span class="line"><span class="string"># [IMPORTANT]: YOU WILL BE PENALIZED IF YOU INCLUDE INFORMATION FROM ASSISTANT OR SYSTEM MESSAGES.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Types of Information to Remember:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Store Personal Preferences: Keep track of likes, dislikes, and specific preferences in various categories such as food, products, activities, and entertainment.</span></span><br><span class="line"><span class="string">2. Maintain Important Personal Details: Remember significant personal information like names, relationships, and important dates.</span></span><br><span class="line"><span class="string">3. Track Plans and Intentions: Note upcoming events, trips, goals, and any plans the user has shared.</span></span><br><span class="line"><span class="string">4. Remember Activity and Service Preferences: Recall preferences for dining, travel, hobbies, and other services.</span></span><br><span class="line"><span class="string">5. Monitor Health and Wellness Preferences: Keep a record of dietary restrictions, fitness routines, and other wellness-related information.</span></span><br><span class="line"><span class="string">6. Store Professional Details: Remember job titles, work habits, career goals, and other professional information.</span></span><br><span class="line"><span class="string">7. Miscellaneous Information Management: Keep track of favorite books, movies, brands, and other miscellaneous details that the user shares.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>具体的few shot例子如下：给了一些正例和反例(不用提取的例子)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AGENT_MEMORY_EXTRACTION_PROMPT = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">User: Hi.</span></span><br><span class="line"><span class="string">Assistant: Hello! I enjoy assisting you. How can I help today?</span></span><br><span class="line"><span class="string">Output: &#123;&#123;&quot;facts&quot; : []&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User: There are branches in trees.</span></span><br><span class="line"><span class="string">Assistant: That&#x27;s an interesting observation. I love discussing nature.</span></span><br><span class="line"><span class="string">Output: &#123;&#123;&quot;facts&quot; : []&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User: Hi, I am looking for a restaurant in San Francisco.</span></span><br><span class="line"><span class="string">Assistant: Sure, I can help with that. Any particular cuisine you&#x27;re interested in?</span></span><br><span class="line"><span class="string">Output: &#123;&#123;&quot;facts&quot; : [&quot;Looking for a restaurant in San Francisco&quot;]&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User: Yesterday, I had a meeting with John at 3pm. We discussed the new project.</span></span><br><span class="line"><span class="string">Assistant: Sounds like a productive meeting. I&#x27;m always eager to hear about new projects.</span></span><br><span class="line"><span class="string">Output: &#123;&#123;&quot;facts&quot; : [&quot;Had a meeting with John at 3pm and discussed the new project&quot;]&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">User: Hi, my name is John. I am a software engineer.</span></span><br><span class="line"><span class="string">Assistant: Nice to meet you, John! My name is Alex and I admire software engineering. How can I help?</span></span><br><span class="line"><span class="string">Output: &#123;&#123;&quot;facts&quot; : [&quot;Name is John&quot;, &quot;Is a Software engineer&quot;]&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不知道这种写法会不会限制LLM输出用户不想要的，prompt里面存在类似下面的句子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [IMPORTANT]: GENERATE FACTS SOLELY BASED ON THE USER&#x27;S MESSAGES. DO NOT INCLUDE INFORMATION FROM ASSISTANT OR SYSTEM MESSAGES.</span></span><br><span class="line"><span class="comment"># [IMPORTANT]: YOU WILL BE PENALIZED IF YOU INCLUDE INFORMATION FROM ASSISTANT OR SYSTEM MESSAGES.</span></span><br></pre></td></tr></table></figure><p>获取到哪些用户的习惯或者其它一些与用户相关信息之后，然后使用embedding匹配从memory中召回一些与这些信息相关的信息；具体的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># new_retrieved_facts 即是从这条消息中获取到的用户偏好</span></span><br><span class="line"><span class="keyword">for</span> new_mem <span class="keyword">in</span> new_retrieved_facts:</span><br><span class="line">    messages_embeddings = <span class="variable language_">self</span>.embedding_model.embed(new_mem, <span class="string">&quot;add&quot;</span>)</span><br><span class="line">    new_message_embeddings[new_mem] = messages_embeddings</span><br><span class="line">    existing_memories = <span class="variable language_">self</span>.vector_store.search(</span><br><span class="line">        query=new_mem,</span><br><span class="line">        vectors=messages_embeddings,</span><br><span class="line">        limit=<span class="number">5</span>,</span><br><span class="line">        filters=search_filters,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> mem <span class="keyword">in</span> existing_memories:</span><br><span class="line">        retrieved_old_memory.append(&#123;<span class="string">&quot;id&quot;</span>: mem.<span class="built_in">id</span>, <span class="string">&quot;text&quot;</span>: mem.payload.get(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回溯到相关的历史memory之后，然后使用LLM确定是否添加新的记忆，还是删除更新旧的记忆，具体的职责相关prompt如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_UPDATE_MEMORY_PROMPT = <span class="string">&quot;&quot;&quot;You are a smart memory manager which controls the memory of a system.</span></span><br><span class="line"><span class="string">You can perform four operations: (1) add into the memory, (2) update the memory, (3) delete from the memory, and (4) no change.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Based on the above four operations, the memory will change.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Compare newly retrieved facts with the existing memory. For each new fact, decide whether to:</span></span><br><span class="line"><span class="string">- ADD: Add it to the memory as a new element</span></span><br><span class="line"><span class="string">- UPDATE: Update an existing memory element</span></span><br><span class="line"><span class="string">- DELETE: Delete an existing memory element</span></span><br><span class="line"><span class="string">- NONE: Make no change (if the fact is already present or irrelevant)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>few shot 的例子如下：展示的是删除这个操作的例子，完整的可以看mem0&#x2F;configs&#x2F;prompts.py 文件中的DEFAULT_UPDATE_MEMORY_PROMPT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_UPDATE_MEMORY_PROMPT = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are specific guidelines to select which operation to perform:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **Delete**: If the retrieved facts contain information that contradicts the information present in the memory, then you have to delete it. Or if the direction is to delete the memory, then you have to delete it.</span></span><br><span class="line"><span class="string">Please note to return the IDs in the output from the input IDs only and do not generate any new ID.</span></span><br><span class="line"><span class="string">- **Example**:</span></span><br><span class="line"><span class="string">    - Old Memory:</span></span><br><span class="line"><span class="string">        [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;id&quot; : &quot;0&quot;,</span></span><br><span class="line"><span class="string">                &quot;text&quot; : &quot;Name is John&quot;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;id&quot; : &quot;1&quot;,</span></span><br><span class="line"><span class="string">                &quot;text&quot; : &quot;Loves cheese pizza&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    - Retrieved facts: [&quot;Dislikes cheese pizza&quot;]</span></span><br><span class="line"><span class="string">    - New Memory:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">        &quot;memory&quot; : [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;id&quot; : &quot;0&quot;,</span></span><br><span class="line"><span class="string">                    &quot;text&quot; : &quot;Name is John&quot;,</span></span><br><span class="line"><span class="string">                    &quot;event&quot; : &quot;NONE&quot;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;id&quot; : &quot;1&quot;,</span></span><br><span class="line"><span class="string">                    &quot;text&quot; : &quot;Loves cheese pizza&quot;,</span></span><br><span class="line"><span class="string">                    &quot;event&quot; : &quot;DELETE&quot;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>        </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="1-3-其它"><a href="#1-3-其它" class="headerlink" title="1.3 其它"></a>1.3 其它</h4><p>memory&#x2F;telemetry.py 文件，这个文件的作用类似埋点，用来记录用户使用mem0的数据情况（在gemini cli， qwen code中看到同样的文件）</p>]]></content>
      
      
      <categories>
          
          <category> Agent开源项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM memory</title>
      <link href="/2025/12/01/LLM-memory/"/>
      <url>/2025/12/01/LLM-memory/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://mp.weixin.qq.com/s/lhb8fI8JbhRGKIrPIc5hJw?poc_token=HF8pLWmjxuFHk8JTOg3JmyE4SBkpcixgjmie8JkP">LLM memory evaluation</a></li><li><a href="https://github.com/EverMind-AI/EverMemOS/tree/main/evaluation">EverMemos</a></li><li><a href="https://github.com/MemTensor/MemOS">MemOS</a></li><li><a href="https://github.com/getzep/zep">zep</a></li><li><a href="https://github.com/NevaMind-AI/memU">memu</a></li><li><a href="https://github.com/letta-ai/letta">letta</a></li><li><a href="https://github.com/Shichun-Liu/Agent-Memory-Paper-List">北大出品，最火、最全的Agent记忆综述！！</a> 相关<a href="https://mp.weixin.qq.com/s/4q4bgDEOzTPUubnaYzG4wA">微信公众号地址</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LightRAG</title>
      <link href="/2025/11/28/LightRAG/"/>
      <url>/2025/11/28/LightRAG/</url>
      
        <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>待详细看完完整论文后补充，大概就是GraphRag虽然效果比较好，但是速度慢，建立图的过程中消耗的token也很多，因此有了LightRag；</p><h3 id="2-LightRAG的原理"><a href="#2-LightRAG的原理" class="headerlink" title="2. LightRAG的原理"></a>2. LightRAG的原理</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/4821793882">深度解析比微软的GraphRAG简洁很多的LightRAG，一看就懂</a></p></blockquote><p>先看了知乎上的一些解读，感觉就是简化版本的GraphRAG，在索引阶段的处理方式是差不多的，只是LightRAG将GraphRAG中比较慢的部分去掉了(社区报告部分，因此也去掉了global search)，数据处理流程是：先分块，然后提取实体和关系，然后入库，index部分的工作就完成了；</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251128151441858.png" alt="image-20251128151441858" style="zoom: 67%;" /><p>在查询阶段，提供了4中方式：</p><ul><li>最基本的向量相似度匹配</li><li>local search: 根据用户的query生成一些low-level 的关键词，然后根据生成的关键词去建立好的图谱查询；</li><li>global search: 根据用户的query生成一些high-level 的关键词，然后根据生成的关键词去建立好的图谱查询；</li><li>混合搜索：local search + global search</li></ul><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251128151926968.png" alt="image-20251128151926968"></p><h3 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h3><ul><li><input disabled="" type="checkbox"> TODO</li></ul>]]></content>
      
      
      <categories>
          
          <category> RAG框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AgentScope源码学习</title>
      <link href="/2025/11/25/AgentScope%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/11/25/AgentScope%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="AgentScope-阿里的"><a href="#AgentScope-阿里的" class="headerlink" title="AgentScope (阿里的)"></a>AgentScope (阿里的)</h3><blockquote><p><a href="https://github.com/agentscope-ai/agentscope">https://github.com/agentscope-ai/agentscope</a></p></blockquote><h4 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h4><p>长期记忆部分使用了mem0这个工具，当然，代码里面也提到了，可以使用阿里自家的ReMe这个记忆框架；</p><p>在26年1月份的更新中，添加了数据库的支持(使用Redis和Sql)，使用Redis应该是保存临时的对话历史信息，Sql是为了保存长期记忆；</p><h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h4><p>这一块儿使用的是基本的React模式，输出最后的回答，也成了一个工具；多了一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### AgentBase</span></span><br><span class="line"><span class="comment"># 在AgentBase里面有一个虚函数 reply</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reply</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 在ReactAgentBase里面有基本的React框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_reasoning</span>()   <span class="comment"># 虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_acting</span>()      <span class="comment"># 虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 在ReactAgent里面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reply</span>():           这里就类似OpenManus里面的step()函数的作用了，从源码来看，逻辑完全一样</span><br><span class="line">    <span class="variable language_">self</span>._reasoning()</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable language_">self</span>._acting()</span><br></pre></td></tr></table></figure><p>在Agent里面有一个observe，感觉是为了观察到外界信息准备的接口(用于多Agent之间的信息互动)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">observe</span>(<span class="params">self, msg: Msg | <span class="built_in">list</span>[Msg] | <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Receive the given message(s) without generating a reply.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        msg (`Msg | list[Msg] | None`):</span></span><br><span class="line"><span class="string">            The message(s) to be observed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">        <span class="string">f&quot;The observe function is not implemented in&quot;</span></span><br><span class="line">        <span class="string">f&quot; <span class="subst">&#123;self.__class__.__name__&#125;</span> class.&quot;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="多Agent互动"><a href="#多Agent互动" class="headerlink" title="多Agent互动"></a>多Agent互动</h4><p>在这个框架里面使用的是swarm模式，似乎比较简单，每个agent observe其它agent的输出，添加到自己的记忆里面去就好了</p><p>在src&#x2F;pipeline&#x2F;_msghub.py文件夹里面 （或者见类名时的说明）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">broadcast</span>(<span class="params">self, msg: <span class="built_in">list</span>[Msg] | Msg</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Broadcast the message to all participants.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        msg (`list[Msg] | Msg`):</span></span><br><span class="line"><span class="string">            Message(s) to be broadcast among all participants.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> agent <span class="keyword">in</span> <span class="variable language_">self</span>.participants:</span><br><span class="line">        <span class="keyword">await</span> agent.observe(msg)</span><br></pre></td></tr></table></figure><h4 id="Interrupt-中断介入"><a href="#Interrupt-中断介入" class="headerlink" title="Interrupt(中断介入)"></a>Interrupt(中断介入)</h4><p>这个好像还不错，可以看一下，文档在<a href="https://doc.agentscope.io/tutorial/task_tool.html#interrupting-tool-execution%EF%BC%8C">https://doc.agentscope.io/tutorial/task_tool.html#interrupting-tool-execution，</a> 对于工具执行的取消，是利用了asyncio的取消机制来实现的</p><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p>使用了python元编程来实现，在元类中添加一些</p><h4 id="Plan的实现"><a href="#Plan的实现" class="headerlink" title="Plan的实现"></a>Plan的实现</h4><p>实现了一些plan的功能函数，然后让Agent去调用和更改当前的plan</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251119115208155.png" alt="image-20251119115208155"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>字节也出了一个类似框架：<a href="https://github.com/volcengine/veadk-python">veadk-python</a></p>]]></content>
      
      
      <categories>
          
          <category> Agent开源项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>smolagents源码学习</title>
      <link href="/2025/11/25/smolagents%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/11/25/smolagents%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/huggingface/smolagents">https://github.com/huggingface/smolagents</a></p></blockquote><h4 id="memory-管理"><a href="#memory-管理" class="headerlink" title="memory 管理"></a>memory 管理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AgentMemory</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, system_prompt:<span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.system_prompt: SystemPromptStep = SystemPromptStep(system_prompt=system_prompt)</span><br><span class="line">        <span class="variable language_">self</span>.steps: <span class="built_in">list</span>[TaskStep | ActionStep | PlanningStep] = []</span><br></pre></td></tr></table></figure><p>将LLM执行过程的信息划分成了四个部分(主要，其它)：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20250926172929838.png" alt="image-20250926172929838"></p><ul><li>TaskStep: 与用户输入相关 (用户提问，上传图片等)</li><li>SystemPromptStep: 系统的prompt</li><li>PlanningStep: 与规划相关的记忆 (<strong>暂时还没遇到</strong>)</li><li>ActionStep：当前送到LLM进行执行的信息</li></ul><p><strong>历史信息的获取</strong></p><p>所以主要在于上面每种类型记忆数据 <code>to_messages</code>的实现 需要注意的是前后信息的完整性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># agents.py line:1256</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_step_stream</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, memory_step: ActionStep</span></span><br><span class="line"><span class="params">    </span>) -&gt; Generator[ChatMessageStreamDelta | ToolCall | ToolOutput | ActionOutput]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Perform one step in the ReAct framework: the agent thinks, acts, and observes the result.</span></span><br><span class="line"><span class="string">    Yields ChatMessageStreamDelta during the run if streaming is enabled.</span></span><br><span class="line"><span class="string">    At the end, yields either None if the step is not final, or the final answer.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    memory_messages = <span class="variable language_">self</span>.write_memory_to_messages()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># agents.py line:758</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_memory_to_messages</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        summary_mode: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">list</span>[ChatMessage]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Reads past llm_outputs, actions, and observations or errors from the memory into a series of messages   that can be used as input to the LLM. Adds a number of keywords (such as PLAN, error, etc) to help  the LLM.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    messages = <span class="variable language_">self</span>.memory.system_prompt.to_messages(summary_mode=summary_mode)</span><br><span class="line">    <span class="keyword">for</span> memory_step <span class="keyword">in</span> <span class="variable language_">self</span>.memory.steps:</span><br><span class="line">        messages.extend(memory_step.to_messages(summary_mode=summary_mode))</span><br><span class="line">    <span class="keyword">return</span> messages</span><br></pre></td></tr></table></figure><h4 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h4><p>当超过最大尝试次数（默认是20次）时，最后会总结19步的step，然后给出一个最终答案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># agent.py  line:810</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">provide_final_answer</span>(<span class="params">self, task: <span class="built_in">str</span></span>) -&gt; ChatMessage:</span><br><span class="line">    </span><br><span class="line">    messages : 这里有一个专门针对这种情况的系统prompt</span><br><span class="line">    messages += <span class="variable language_">self</span>.write_memory_to_messages()[<span class="number">1</span>:]</span><br><span class="line">    messages : 需要组装的post_messages</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chat_message: ChatMessage = <span class="variable language_">self</span>.model.generate(messages)</span><br><span class="line">        <span class="keyword">return</span> chat_message</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> ChatMessage(</span><br><span class="line">            role=MessageRole.ASSISTANT,</span><br><span class="line">            content=[&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: <span class="string">f&quot;Error in generating final LLM output: <span class="subst">&#123;e&#125;</span>&quot;</span>&#125;],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="Agent-CodeAgent"><a href="#Agent-CodeAgent" class="headerlink" title="Agent: CodeAgent"></a>Agent: CodeAgent</h4><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20250929112702011.png" alt="image-20250929112702011"></p><p>项目的CodeAgent模式算是这个项目里面比较新颖的一种方式了，调用工具的API是通过执行python代码的方式来执行的，但是感觉解析python的AST那部分，就感觉好复杂-_-#，没有FunctionCall的这种方式简洁了。</p><p>来源于<a href="https://link.zhihu.com/?target=https://huggingface.co/papers/2402.01030">Executable Code Actions Elicit Better LLM Agents</a>，这篇论文主要的出发动机是当前LLM Agent通常通过以预定义的格式生成 JSON 或文本来生成Action，这通常受到<strong>约束动作空间（例如，预定义工具的范围）和受限灵活性（例如，无法组合多个工具）的限制</strong>。</p><blockquote><p>链接：<a href="https://zhuanlan.zhihu.com/p/16341067315">https://zhuanlan.zhihu.com/p/16341067315</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Agent开源项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCP</title>
      <link href="/2025/11/25/mcp%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/11/25/mcp%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p>话不多说，直接上图即可</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20250821171413971.png" alt="image-20250821171413971"></p><p>有MCP和没有MCP的区别，提升了效率</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20250821171443789.png" alt="image-20250821171443789"></p><p>MCP的架构图：主要是由Host、Client和Server三部分组成</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20250821171800487.png" alt="image-20250821171800487"></p><h2 id="个人demo"><a href="#个人demo" class="headerlink" title="个人demo"></a>个人demo</h2><blockquote><p><a href="https://github.com/flippy-bird/agent/tree/main/examples/mcp_demo">mcp demo</a></p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/29001189476">MCP (Model Context Protocol)，一篇就够了。</a></li><li><a href="https://github.com/modelcontextprotocol/python-sdk">python SDK的官方文档</a></li><li></li><li>测试MCP工具接入使用的地址：<a href="https://bailian.console.aliyun.com/?utm_content=se_1021227952&gclid=EAIaIQobChMI28G-yLObjwMV3JC5BR0zMijXEAAYASAAEgKc4_D_BwE&tab=mcp#/mcp-market">阿里MCP</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> MCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大模型入门(组内分享)</title>
      <link href="/2025/06/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%85%A5%E9%97%A8-%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB/"/>
      <url>/2025/06/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%85%A5%E9%97%A8-%E7%BB%84%E5%86%85%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code> 2025年开年以来，大家或多或少都听过下面这些词：deepseek， AI， 人工智能，Agent，具身智能；</code></pre><p>AI到底发展到哪一步了，利用AI可以做哪些事情，或者作为技术人员，想要使用AI做一些事情，应该学习那些东西，这篇将和大家一起探讨下。</p><p>备注声明：<strong>该分享定位轻科普向</strong>，不会涉及大模型相关的底层原理，有些结论属于个人的理解和感悟，如需要深入交流，欢迎大家和我深入探讨。</p><h2 id="大模型相关应用"><a href="#大模型相关应用" class="headerlink" title="大模型相关应用"></a>大模型相关应用</h2><h3 id="Prompt-Engineer-提示词"><a href="#Prompt-Engineer-提示词" class="headerlink" title="Prompt Engineer(提示词)"></a><strong>Prompt Engineer(提示词)</strong></h3><p><strong>Prompt 咒语 —-&gt; 激发LLM的潜能</strong></p><p>2023年的某一天，当你开始和ChatGpt互动的那一刻开始，你就是一个Prompt Engineer了！  </p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=MGIxMzNhZDIyMWY5OWM5ZDExMzA2ZDZmODE2Nzg4YWVfTkk2b1pXcDBCbVdCbUdXa2ZzMDl6T0psM09oa0dIaTFfVG9rZW46RmJiTmIyVjl2b3Nnbmh4SUdpYmNZbjVXblRmXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>当你不断试探GPT，使用各种策略，反问，试探，举个例子等等(专业一点就是few shot, zero-shot, cot等等)，最终得到正确答案时，你其实已经获得了一些prompt Engineer的训练，在下一次的问答中，你就能更快更好地得到你想要的答案；</p><p>当然啦，现在大模型也挺多的，确实有一些朴素的咒语框架可以让我们快速得到更好了的回答，你如果想了解一下，可以看看下面这个课程</p><p><a href="https://www.bilibili.com/video/BV1b4A6etEJu/?spm_id_from=333.337.search-card.all.click&vd_source=d46df11a3bf332ea68a6f3b7af79095d">(超爽中英!) 2025吴恩达最好的【提示词工程师】教程！附课件代码 DeepLearning.AI_大模型_LLM_Prompt_哔哩哔哩_bilibili</a></p><p>当然，上面说的咒语是GPT对话形式的，文生图，文生视频等等AIGC的应用，咒语可能需要另外习得(你芝麻开门可以开这个门，另外一个门可就不行了哦)</p><h3 id="SFT-微调"><a href="#SFT-微调" class="headerlink" title="SFT(微调)"></a>SFT(微调)</h3><ul><li>大模型训练的时候使用的是公开的数据集，prompt咒语念得再好，也没办法，巧妇难为无米之炊，对于特定领域的问题大模型会出现幻觉(瞎回答)</li><li>大模型的效果出现一些问题，需要纠正大模型的错误</li></ul><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc4ODQ0YzNlZDNlMTJkYmY3MmUzM2U0OTI3MzA2OGZfdzVnUFRKeW5sdHZDRG9OZkJONlFiUWJIM2RTYXp6QjBfVG9rZW46QkJiVWJTYlhpb0RZZDF4MzRWdWNsNDd4bkx1XzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><ul><li>改变大模型回答的风格等等需要定制，就需要大模型微调</li></ul><p>如果大家想要进阶动手微调一下的话，可以使用下面的框架，按照格式准备好数据即可，然后一键启动，上机器开始炼丹即可！</p><p>目前主流的微调框架：</p><ol><li><a href="https://github.com/hiyouga/LLaMA-Factory">https://github.com/hiyouga/LLaMA-Factory</a></li><li><a href="https://github.com/unslothai/unsloth">https://github.com/unslothai/unsloth</a></li><li><a href="https://github.com/modelscope/ms-swift">https://github.com/modelscope/ms-swift</a></li></ol><h3 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a><strong>RAG</strong></h3><p><strong>RAG &#x3D; LLM + 外置数据库</strong></p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=NmJhOWRlYmQ0OTNiMzMzOGY2YjdlYjE0ZTM1ODY3NDBfcVFTWERpODZRZzBxWmRaTU1xdDJwaHIweE9kVFNwZXNfVG9rZW46UzI1TGJlMDJPb1Y5bHh4M1JFSmNHNll1bldkXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTMxZjhmYmRlZDYzOWMwYTcxNDhlZDhjYjM3ODllNzdfdVZyWmkwU1hDeXBUZGl5U051UlZyZmZjQXJJaDZ3c25fVG9rZW46QlBEUmJTbFFNbzdqVnZ4Sm1WaGNhYzZRbjZlXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>​                                                                   <strong>备注：这部分写于2025年4月16日</strong></p><p>用过GPT的同学可能会了解到，GPT的知识具有时效性，比如GPT-4发布时间在2023年，那么GPT-4绝对无法帮你回答2024年之后的事情；再者，你有一个本地知识库的时候，你需要大模型结合这个知识库来回答你的问题时，你可能就需要RAG了；</p><p>右边严格来说不是RAG的流程，但是广义来讲，也算RAG，llm在其中扮演的是嘴替(总结)的作用；左边这个图是标准的RAG的流程，主要包括两个部分：index(入库) 和 query(出库)</p><p>如果大家想要深入学习这一部分的话，下面是一些可以进阶的部分：</p><p>当前两个主流的RAG搭建框架(RAG企业级开发)：</p><p>langchain：<a href="https://github.com/langchain-ai/langchain">https://github.com/langchain-ai/langchain</a></p><p>llamaindex：<a href="https://github.com/run-llama/llama_index">https://github.com/run-llama/llama_index</a></p><p>可以学习的开源项目：</p><p>QAnything: <a href="https://github.com/netease-youdao/QAnything">https://github.com/netease-youdao/QAnything</a></p><p>RAGflow：<a href="https://github.com/infiniflow/ragflow/blob/main/README_zh.md">https://github.com/infiniflow/ragflow/blob/main/README_zh.md</a></p><p>关于RAG的优化：<a href="https://quvideo.feishu.cn/docx/EbMAde0dcoBe6ZxjbRecgaQ3ngg">RAG技术</a></p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p><strong>Agent &#x3D; LLM + 外部工具</strong></p><p>上面的RAG是LLM和外部的知识(文档，图片等)打通了一条链路，相当于在数据层面建立了联系；但是不具备数据处理的能力，而处理数据的能力，一般是API是通过API的形式来展现的；**因此当LLM能够使用外部的 工具(API), LLM的能力将得到极大的扩展 ，**不多bb，展示！！！</p><blockquote><p><a href="https://strudel.cc/">https://strudel.cc/</a>  (下面Agent使用到的一个音乐工具)</p></blockquote><p>如果没有耐心看完前面Agent执行步骤的话，可直接拉到2：48秒，然后看后面的即可</p><p><video data-lark-video-uri="drivetoken://KSrPbAyRYo98nmx2MYucxGg9nbb" data-lark-video-mime="video/mp4" data-lark-video-size="15891280" data-lark-video-duration="0" data-lark-video-name="test.mp4" data-lark-video-width="1920" data-lark-video-height="1080"></video></p><p>如果给了LLM一台可以运行的电脑(环境)，那么这就是今年3月份爆火的AI智能体 <a href="https://manus.im/">Manus</a></p><p>为什么要叫Agent呢，可以看下面的图(没找到比较好的图，自己画的，见谅)，我们可以将用户比作boss，llm比作员工，boss发出一个问题之后，llm去规划并完成工作，llm是具体的执行者，因此叫做代理,Agent</p><p>暂时无法在飞书文档外展示此内容</p><p>目前智能Agent产品设计一般都是按照上面的思路去进行的，规划(Plan) + 执行(ReAct模型)</p><h2 id="Agent-1"><a href="#Agent-1" class="headerlink" title="Agent"></a>Agent</h2><p>通过上面的章节，对Agent进行了一些初步的了解，这个小节将通过代码进一步的带大家了解Agent相关的内容</p><h3 id="Agent-2"><a href="#Agent-2" class="headerlink" title="Agent"></a>Agent</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1FCR3Y1EnJ/?spm_id_from=333.337.search-card.all.click">李宏毅讲Agent</a></p></blockquote><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRmNmM1Y2M0YTJmY2VmMDQ5N2Y4YjBiZGE4MDdkZDZfUzZnOHN3VzFCajRmd2tLajZyTXFvSkNWNEpaRFVYMFRfVG9rZW46TTc2NmJzQmVMb3dyamx4NEhQN2NSVFA3bkFjXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>从上面的一些例子我们可以了解到，对于完成一个人类目标而言，Agent需要两个方面的能力，目标拆解的能力和分布执行的能力；对应的名词即plan和function call，有了分步的任务，之后，LLM Agent逐步分析，调用工具或者自身内部知识，然后将结果传给下一步的任务，如下图所示：</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTkyZTU0OTZkMDg5YmUyMmVjZWFmNjkxZWU1OGJmMTBfaW1CUU1iNDBWUUZlU0pITXhUY1pLZWMwMmNrZ25ZTmhfVG9rZW46RWpVRmI3cENEb2cyUnd4NlhKMmNuT0FFbmNlXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>通过上面的方式，可以有哪些运用呢？</p><ol><li>用模型训练模型：</li></ol><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNiZDAwMmI5NDQ5ODFkZGNjMWQxMGRhZTA5MTU3NzJfallCNmE0MldDMnp2aWVEbFJHVFZyVEtNU00zbnBrZDVfVG9rZW46T1ZqbGJZYTFzb3lPRGJ4NUxFb2NJSzAxblJoXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><ol><li>使用Agent下围棋，使用电脑，浏览网页等等！</li></ol><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWMzOTA3ZTQ3NTkzN2IyNTg4Y2E3Y2Q2MzAxZWQwMzFfRENLbXpqRHRBTmVTWlBBaGNYZDNlaWtpcUptcjk4bUhfVG9rZW46TWJDVWJoTUk0b2puY0J4MXl2eWNxTk9IbmZkXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>当然上面的例子也说明了，大模型在调用过程中，可能出现幻觉，这有可能导致任务执行的失败，比如上面的deepseek 改变了国际象棋的规则，然后赢得了AI届的国际象棋桂冠！因此对于复杂问题，选择其它方法或许更可靠。这里不再展开。</p><p>上面都提到了大模型要实现Agent，需要具备工具调用的能力，这个能力是怎么实现的呢？看图好像挺简单的一句话就说完了，其实实际呢，也挺简单的。下面通过一个Function Call的例子来简单说明一下。</p><h3 id="Function-call"><a href="#Function-call" class="headerlink" title="Function call"></a>Function call</h3><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzRkNWVhM2VlY2ViZTM2OThjMzMxOTYwNzdkYzA5MDdfbjNEVlpFZXc3M0pFbnJReFIyZXNmUDNzajdFa1BMVU1fVG9rZW46WjJrZmI1UVpqb0NJQmN4c05rSGN6MjFJbjhjXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>调用的实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 定义工具</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_current_time</span>():</span><br><span class="line">    current_datetime = datetime.now()</span><br><span class="line">    formatted_time = current_datetime.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;当前时间：<span class="subst">&#123;formatted_time&#125;</span>。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">arguments</span>):</span><br><span class="line">    a = arguments[<span class="string">&quot;num_1&quot;</span>]</span><br><span class="line">    b = arguments[<span class="string">&quot;num_2&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;计算的结果是：<span class="subst">&#123;a + b&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 创建tools数组</span></span><br><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_current_time&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;当你想知道现在的时间时非常有用。&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">tool_name = [tool[<span class="string">&quot;function&quot;</span>][<span class="string">&quot;name&quot;</span>] <span class="keyword">for</span> tool <span class="keyword">in</span> tools]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3：使用大模型调用函数</span></span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">    api_key=<span class="string">&quot;sk-389c222d8f304e6ba3bb10ad3589d340&quot;</span>,</span><br><span class="line">    base_url=<span class="string">&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;&quot;&quot;你是一个很有帮助的助手。如果用户提问关于时间的问题，请调用‘get_current_time’函数。</span></span><br><span class="line"><span class="string">     请以友好的语气回答问题。&quot;&quot;&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;现在是几点？&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_calling</span>():</span><br><span class="line">    completion = client.chat.completions.create(</span><br><span class="line">        model=<span class="string">&quot;qwen-max&quot;</span>,</span><br><span class="line">        messages=messages,</span><br><span class="line">        tools=tools,</span><br><span class="line">    )</span><br><span class="line">    res = completion.choices[<span class="number">0</span>].message</span><br><span class="line">    <span class="built_in">print</span>(res.model_dump_json())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> completion</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4: 运行工具函数</span></span><br><span class="line">completion = function_calling()</span><br><span class="line">function_name = completion.choices[<span class="number">0</span>].message.tool_calls[<span class="number">0</span>].function.name</span><br><span class="line">arguments_string = completion.choices[<span class="number">0</span>].message.tool_calls[<span class="number">0</span>].function.arguments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用json模块解析参数字符串</span></span><br><span class="line">arguments = json.loads(arguments_string)</span><br><span class="line"><span class="comment"># 创建一个函数映射表</span></span><br><span class="line">function_mapper = &#123;</span><br><span class="line">    <span class="string">&quot;get_current_time&quot;</span>: get_current_time,</span><br><span class="line">    <span class="string">&quot;add&quot;</span>:add</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取函数实体</span></span><br><span class="line">function = function_mapper[function_name]</span><br><span class="line"><span class="comment"># 如果入参为空，则直接调用函数</span></span><br><span class="line"><span class="keyword">if</span> arguments == &#123;&#125;:</span><br><span class="line">    function_output = function()</span><br><span class="line"><span class="comment"># 否则，传入参数后调用函数</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    function_output = function(arguments)</span><br><span class="line"><span class="comment"># 打印工具的输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;工具函数输出：<span class="subst">&#123;function_output&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## step5： 将工具输出添加到messages中，继续进行下面的步骤</span></span><br><span class="line">messages.append(completion.choices[<span class="number">0</span>].message)</span><br><span class="line">messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>, <span class="string">&quot;content&quot;</span>: function_output, <span class="string">&quot;tool_call_id&quot;</span>: completion.choices[<span class="number">0</span>].message.tool_calls[<span class="number">0</span>].<span class="built_in">id</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;已添加tool message\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">completion = function_calling()</span><br></pre></td></tr></table></figure><h3 id="WorkFlow-编排的Agent"><a href="#WorkFlow-编排的Agent" class="headerlink" title="WorkFlow - 编排的Agent"></a>WorkFlow - 编排的Agent</h3><p>上面提到，对于复杂任务，完全让大模型去规划，去自由探索，可能出现很多不可预知的问题，这对于一些确定性的任务来说，是很致命的，既然这样，那么就别让大模型逞能，脚踏实地，只解决具体的单步问题，规划问题让人类来干就好了，这就是workflow，这就是截止到2025年4月20日来最主流的Agent 实现方式；</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=MTI4YjNlMzcwOThjOWMyNmUyNDZkYWFmNzU2M2U4ZDRfNGZWR3ZLY3JtRmNFWXpxOFV0VU5DSGZ5a3RPdFBZUGJfVG9rZW46WmhBamJVQmhYb2FPd2Z4eHVjTGNYdlpObkFjXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><h3 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h3><p>上面是通义千问的Function 调用方式，下次我们再添加一个新的工具的时候，是不是又要重复写一下这个流程(定义工具，定义工具描述，然后传给大模型)， 但是现在大模型这么多，大模型之间的Function Call的方式可能不相同，这里写的工具函数，换到GPT4，可能就要修改代码，这样很不符合程序员的复用规则，因此有了MCP</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQxMDM4YjJhMDMyNGE4Yzg5YTYwY2IxMTc3NjlmMmRfdnhxMUJtNGhKMTBQTVJqQzdTUE1xc2lxeFM4Rk5aVmVfVG9rZW46WmNQS2JxR05Jb3FuTkR4UFgzamNpMGx0bmRjXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTZkMmJkMWU3N2NlMTc1NWNiYjEzMDFiNjUwZGNjMjNfRkNxVGc4U0U1a3UySGN2SjVBaTA2Q3RXMGx4QTBGanNfVG9rZW46VWZ5VmJvOU1Rb2lsN3d4SWFwYWNjM29UbmxiXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>MCP其实还是大模型选择需要调用的工具，<strong>因此MCP本质还是Function Call，</strong> 只是统一了一个标准之后，开发者通过MCP协议写的Function可以给别人复用了</p><p>如果想深入了解的话，大家可以对照着<a href="https://github.com/modelcontextprotocol">官方代码</a>写一遍，就会发现了MCP解决的是哪一方面的问题了；</p><h3 id="A2A，ANP等等"><a href="#A2A，ANP等等" class="headerlink" title="A2A，ANP等等"></a>A2A，ANP等等</h3><p><a href="https://github.com/google/A2A">A2A</a>：谷歌提出来的一种 Agent 和 Agent相互通信的协议， MCP协议统一了大模型与外界工具交互的方式，A2A是Agent与Agent间的，可以类比成公司里面部门，每个部门承担一部功能(如前端，后端，数据，算法，HR，财务，运维等)，然后相互协作，共同达成一个目标；</p><p><a href="https://github.com/agent-network-protocol/AgentNetworkProtocol">ANP</a>：国内提出的类似于A2A的，用于Agent2Agent的协议，目前是成为互联网界的http</p><p>. . . . .</p><p>无论是MCP，还是A2A，抑或者是其它协议，我觉得归根到底是今年自deepseek以来，**大模型的能力得到了较大的提升，**这个生态才慢慢火起来(2024年开年火了一阵就没声音了，因为Agent有点人工智障的味道)，至于Agent有多智能，我觉得还是让子弹飞一会儿，但是在小的方面，确实会影响我们的工作效率；恰当的使用llm来协助我们工作，能做到事半功倍；</p><h3 id="好物推荐"><a href="#好物推荐" class="headerlink" title="好物推荐"></a>好物推荐</h3><p>编程工具类：</p><ol><li><a href="https://www.cursor.com/">Cursor</a>  (目前最好的AI代码编辑器，就是有点小贵，我使用的是VScode通义灵码插件替代)</li><li><a href="https://www.cursor.com/">Trae</a> (字节出品， 国产第一个有知名度的AI代码编辑器(当然，投流，广告投入很大))</li></ol><p>开发框架类:（还是上面那两个）</p><p>langchain：<a href="https://github.com/langchain-ai/langchain">https://github.com/langchain-ai/langchain</a></p><p>llamaindex：<a href="https://github.com/run-llama/llama_index">https://github.com/run-llama/llama_index</a>  (个人常用这个，教程很友好， 但是目前langchain发展更好一些)</p><p>零代码类大模型编排工具(适合AI行业的所有人)</p><p>搞过comfyUI的同学应该知道节点编辑工具的概念，这个就是llm这边的节点编辑工具</p><ol><li><a href="https://github.com/langgenius/dify">dify</a> : 企业级的，目前大多数工具开发AI流程应用的首选</li><li><a href="https://github.com/n8n-io/n8n">n8n</a> ：同上，优势在集成了很多的工具</li><li><a href="https://www.coze.cn/home">扣子</a> ： 字节出品，和dify类似</li></ol><p>举个dify的例子：</p><p>本来想演示一个使用dify搭建小影知识库问答系统的demo，但是貌似飞书文档权限比较严格&#x3D;_&#x3D;#，因此这里简单介绍一下；</p><p>以翻译的任务举个例子(目前主流翻译的流程)：通过搭积木的方式，20分钟(2分钟搭建，18分钟的提示词) 即可快速完成一个任务的搭建</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWNhMzIxZWJhNjYwYjM4ZWQ1YmZmNmYzNjM2NThhZDJfS0Q0YU4zSUN3ZDBVdEloVVNsOE9ES2JUaVNGNEVRcmhfVG9rZW46SkplQmJzak5jb1RYcmF4eVdYZWNoU09Bbm1IXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p>另外，比较喜欢的一个功能是不同模型的对比，我觉得在验证阶段很实用</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=YWMzMzFjYTI0YjY3ZWJlYzRiMWZjNjE1NTk3M2M4OGJfR2xyb2lKQlpnR2xTN29vZ3dPZFJoTFVoT0xtcHdBUWpfVG9rZW46STRGWmJKaHFTb0VXaDR4NzQ1WmMweDY1bmFkXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><h2 id="现场演示"><a href="#现场演示" class="headerlink" title="现场演示"></a>现场演示</h2><h3 id="Agent-3"><a href="#Agent-3" class="headerlink" title="Agent"></a>Agent</h3><p>cline + MCP</p><p>MCP发展得如火如荼，开源社区上也有很多好玩的MCP工具了，大家可以尝试一下</p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkzYTY3MTQwYTdjYWU5NWY2YTViNGZmOWQ5ZGE5NThfSk9DTlU1b2JYNUxBUDJ1V3VEZjRSNVJ6N25PMmhtR0lfVG9rZW46R0VadWI0SmI5b2E0aHZ4MlFQeWNoNGc1bmVnXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><p><strong>想一想：大家现在看到这个热点，大家觉得是通过什么实现的？</strong></p><p><img src="https://quvideo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkxODQxZjhjOTEzNDgzNzU3MTgzNjk0YzFjZTc5OTZfWVhIa3Q1ZTgxTzJkRk9sM09pczB5cFY3Y2x3UUlaOXVfVG9rZW46TmJKeWJvWHU0b2RkSFh4V21KZmNha0ZHbkRjXzE3NjQxNjE5NjQ6MTc2NDE2NTU2NF9WNA" alt="img"></p><h3 id="dify"><a href="#dify" class="headerlink" title="dify"></a>dify</h3><h3 id="ima-好用的结合RAG的文档工具"><a href="#ima-好用的结合RAG的文档工具" class="headerlink" title="ima (好用的结合RAG的文档工具)"></a>ima (好用的结合RAG的文档工具)</h3>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG优化</title>
      <link href="/2025/04/21/RAG%E4%BC%98%E5%8C%96/"/>
      <url>/2025/04/21/RAG%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本的RAG流程-Native-RAG"><a href="#1-基本的RAG流程-Native-RAG" class="headerlink" title="1. 基本的RAG流程-Native RAG"></a>1. 基本的RAG流程-Native RAG</h3><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/2.png" alt="2" style="zoom:33%;" /><h3 id="2-RAG优化"><a href="#2-RAG优化" class="headerlink" title="2. RAG优化"></a>2. RAG优化</h3><h4 id="2-1-优化chunk"><a href="#2-1-优化chunk" class="headerlink" title="2.1 优化chunk"></a>2.1 优化chunk</h4><p>传统的RAG在数据分块时采用的是固定分块，因为可能会破坏段落的连续性，因此这一方面可以改进</p><h5 id="2-1-1-拼接断裂的块"><a href="#2-1-1-拼接断裂的块" class="headerlink" title="2.1.1 拼接断裂的块"></a>2.1.1 拼接断裂的块</h5><ul><li>将固定分块的断裂部分找到，然后拼接起来；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_breakpoints</span>(<span class="params">similarities, method=<span class="string">&quot;percentile&quot;</span>, threshold=<span class="number">90</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes chunking breakpoints based on similarity drops.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    similarities (List[float]): List of similarity scores between sentences.</span></span><br><span class="line"><span class="string">    method (str): &#x27;percentile&#x27;, &#x27;standard_deviation&#x27;, or &#x27;interquartile&#x27;.</span></span><br><span class="line"><span class="string">    threshold (float): Threshold value (percentile for &#x27;percentile&#x27;, std devs for &#x27;standard_deviation&#x27;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    List[int]: Indices where chunk splits should occur.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Determine the threshold value based on the selected method</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;percentile&quot;</span>:</span><br><span class="line">        <span class="comment"># Calculate the Xth percentile of the similarity scores</span></span><br><span class="line">        threshold_value = np.percentile(similarities, threshold)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;standard_deviation&quot;</span>:</span><br><span class="line">        <span class="comment"># Calculate the mean and standard deviation of the similarity scores</span></span><br><span class="line">        mean = np.mean(similarities)</span><br><span class="line">        std_dev = np.std(similarities)</span><br><span class="line">        <span class="comment"># Set the threshold value to mean minus X standard deviations</span></span><br><span class="line">        threshold_value = mean - (threshold * std_dev)</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;interquartile&quot;</span>:</span><br><span class="line">        <span class="comment"># Calculate the first and third quartiles (Q1 and Q3)</span></span><br><span class="line">        q1, q3 = np.percentile(similarities, [<span class="number">25</span>, <span class="number">75</span>])</span><br><span class="line">        <span class="comment"># Set the threshold value using the IQR rule for outliers</span></span><br><span class="line">        threshold_value = q1 - <span class="number">1.5</span> * (q3 - q1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Raise an error if an invalid method is provided</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid method. Choose &#x27;percentile&#x27;, &#x27;standard_deviation&#x27;, or &#x27;interquartile&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Identify indices where similarity drops below the threshold value</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i, sim <span class="keyword">in</span> <span class="built_in">enumerate</span>(similarities) <span class="keyword">if</span> sim &lt; threshold_value]</span><br></pre></td></tr></table></figure><h5 id="2-1-2-使用不同的分块大小"><a href="#2-1-2-使用不同的分块大小" class="headerlink" title="2.1.2 使用不同的分块大小"></a>2.1.2 使用不同的分块大小</h5><ul><li>(例如原来是256， 现在试一试512， 1000等等)；</li></ul><h5 id="2-1-3-总结chunk"><a href="#2-1-3-总结chunk" class="headerlink" title="2.1.3 总结chunk"></a>2.1.3 总结chunk</h5><ul><li>chunk Embedding之后缺乏语义信息，在chunk Embedding之前 给每一个chunk添加一个meta data, 一般是对这段text的总结，如标题等(可以使用LLM来协助),  在查询时， 使用的是两个信息相似度的平均值 （这个demo）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">system_prompt = <span class="string">&quot;Generate a concise and informative title for the given text.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># **************************** step 2 *********************************</span></span><br><span class="line">chunks = []  <span class="comment"># Initialize an empty list to store chunks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate through the text with the specified chunk size and overlap</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(text), n - overlap):</span><br><span class="line">    chunk = text[i:i + n]  <span class="comment"># Extract a chunk of text</span></span><br><span class="line">    header = generate_chunk_header(chunk)  <span class="comment"># Generate a header for the chunk using LLM</span></span><br><span class="line">    chunks.append(&#123;<span class="string">&quot;header&quot;</span>: header, <span class="string">&quot;text&quot;</span>: chunk&#125;)  <span class="comment"># Append the header and chunk to the list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chunks  <span class="comment"># Return the list of chunks with headers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *************************** step 3 **********************************</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> tqdm(text_chunks, desc=<span class="string">&quot;Generating embeddings&quot;</span>):</span><br><span class="line">    <span class="comment"># Create an embedding for the chunk&#x27;s text</span></span><br><span class="line">    text_embedding = create_embeddings(chunk[<span class="string">&quot;text&quot;</span>])</span><br><span class="line">    <span class="comment"># Create an embedding for the chunk&#x27;s header</span></span><br><span class="line">    header_embedding = create_embeddings(chunk[<span class="string">&quot;header&quot;</span>])</span><br><span class="line">    <span class="comment"># Append the chunk&#x27;s header, text, and their embeddings to the list</span></span><br><span class="line">    embeddings.append(&#123;<span class="string">&quot;header&quot;</span>: chunk[<span class="string">&quot;header&quot;</span>], <span class="string">&quot;text&quot;</span>: chunk[<span class="string">&quot;text&quot;</span>], <span class="string">&quot;embedding&quot;</span>: text_embedding, <span class="string">&quot;header_embedding&quot;</span>: header_embedding&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># ****************************** step 4**************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate through each chunk to calculate similarity scores</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> chunks:</span><br><span class="line">    <span class="comment"># Compute cosine similarity between query embedding and chunk text embedding</span></span><br><span class="line">    sim_text = cosine_similarity(np.array(query_embedding), np.array(chunk[<span class="string">&quot;embedding&quot;</span>]))</span><br><span class="line">    <span class="comment"># Compute cosine similarity between query embedding and chunk header embedding</span></span><br><span class="line">    sim_header = cosine_similarity(np.array(query_embedding), np.array(chunk[<span class="string">&quot;header_embedding&quot;</span>]))</span><br><span class="line">    <span class="comment"># Calculate the average similarity score</span></span><br><span class="line">    avg_similarity = (sim_text + sim_header) / <span class="number">2</span></span><br><span class="line">    <span class="comment"># Append the chunk and its average similarity score to the list</span></span><br><span class="line">    similarities.append((chunk, avg_similarity))</span><br></pre></td></tr></table></figure><h5 id="2-1-4-提问chunk"><a href="#2-1-4-提问chunk" class="headerlink" title="2.1.4 提问chunk"></a>2.1.4 提问chunk</h5><ul><li>同上，不过这里改变了方向，是从chunk中提取问题，而不是总结，换汤不换药， 注意这里的是 问题 + chunk text 向量化之后一起 进行检索，然后找出top-k</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the system prompt to guide the AI&#x27;s behavior</span></span><br><span class="line">system_prompt = <span class="string">&quot;You are an expert at generating relevant questions from text. Create concise questions that can be answered using only the provided text. Focus on key information and concepts.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the text chunk and the number of questions to generate</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Based on the following text, generate <span class="subst">&#123;num_questions&#125;</span> different questions that can be answered using only this text:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="subst">&#123;text_chunk&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Format your response as a numbered list of questions only, with no additional text.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-1-5-提取chunk，不采用固定chunk-size"><a href="#2-1-5-提取chunk，不采用固定chunk-size" class="headerlink" title="2.1.5 提取chunk，不采用固定chunk size"></a>2.1.5 提取chunk，不采用固定chunk size</h5><ul><li><strong>Proposition Chunking</strong></li></ul><p>仅仅采用固定分块，问题太多，会破坏句子的语义，句子不完整时会产生歧义等, 因此这种方法是从每个chunk中提取有用的关键信息作为新的chunk (这里也是使用LLM来分句的)</p><p>主要是两步：分段 然后评估筛选出最符合的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############### 产生新的chunk</span></span><br><span class="line"><span class="comment"># System prompt to instruct the AI on how to generate propositions</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;Please break down the following text into simple, self-contained propositions. </span></span><br><span class="line"><span class="string">Ensure that each proposition meets the following criteria:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Express a Single Fact: Each proposition should state one specific fact or claim.</span></span><br><span class="line"><span class="string">2. Be Understandable Without Context: The proposition should be self-contained, meaning it can be understood without needing additional context.</span></span><br><span class="line"><span class="string">3. Use Full Names, Not Pronouns: Avoid pronouns or ambiguous references; use full entity names.</span></span><br><span class="line"><span class="string">4. Include Relevant Dates/Qualifiers: If applicable, include necessary dates, times, and qualifiers to make the fact precise.</span></span><br><span class="line"><span class="string">5. Contain One Subject-Predicate Relationship: Focus on a single subject and its corresponding action or attribute, without conjunctions or multiple clauses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Output ONLY the list of propositions without any additional text or explanations.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User prompt containing the text chunk to be converted into propositions</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Text to convert into propositions:\n\n<span class="subst">&#123;chunk[<span class="string">&#x27;text&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################# 评估新chunk的质量 (结合原始的chunk)</span></span><br><span class="line"><span class="comment"># System prompt to instruct the AI on how to evaluate the proposition</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at evaluating the quality of propositions extracted from text.</span></span><br><span class="line"><span class="string">Rate the given proposition on the following criteria (scale 1-10):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Accuracy: How well the proposition reflects information in the original text</span></span><br><span class="line"><span class="string">- Clarity: How easy it is to understand the proposition without additional context</span></span><br><span class="line"><span class="string">- Completeness: Whether the proposition includes necessary details (dates, qualifiers, etc.)</span></span><br><span class="line"><span class="string">- Conciseness: Whether the proposition is concise without losing important information</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The response must be in valid JSON format with numerical scores for each criterion:</span></span><br><span class="line"><span class="string">&#123;&quot;accuracy&quot;: X, &quot;clarity&quot;: X, &quot;completeness&quot;: X, &quot;conciseness&quot;: X&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User prompt containing the proposition and the original text</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;Proposition: <span class="subst">&#123;proposition&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-优化处理过程"><a href="#2-2-优化处理过程" class="headerlink" title="2.2 优化处理过程"></a>2.2 优化处理过程</h4><h5 id="2-2-1-分层RAG"><a href="#2-2-1-分层RAG" class="headerlink" title="2.2.1 分层RAG"></a>2.2.1 分层RAG</h5><p>传统的RAG当 text很大时，chunk就很多，匹配chunk缺乏上下文，而且每一个chunk都做相似度计算，计算量大，效率低，因此分层RAG的思想是，先对每一页做一个总结，先在总结中找到相关信息，然后再在对应的页中去找相关的详细信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############## 总结的prompt</span></span><br><span class="line"><span class="comment"># Define the system prompt to instruct the summarization model</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert summarization system.</span></span><br><span class="line"><span class="string">Create a detailed summary of the provided text. </span></span><br><span class="line"><span class="string">Focus on capturing the main topics, key information, and important facts.</span></span><br><span class="line"><span class="string">Your summary should be comprehensive enough to understand what the page contains</span></span><br><span class="line"><span class="string">but more concise than the original.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-GraphRAG"><a href="#2-2-2-GraphRAG" class="headerlink" title="2.2.2 GraphRAG"></a>2.2.2 GraphRAG</h5><p>可参考：<a href="https://zhuanlan.zhihu.com/p/13801755777">GraphRAG快速入门与原理详解</a></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/asynccode" alt="img"></p><ul><li>实体提取 (Node, 节点)：利用LLM进行实体的提取，这些实体通常是指文档中出现的人物、地点、组织、概念等信息。</li><li>关系提取(Edage， 边)：关系挖掘是从文本中识别出实体之间的 关系，例如：谁与谁有关联、某个实体与另一个实体之间的关系是“属于”、“合作”、“对立”等。</li><li>Community(中文翻译成社区，感觉真的很奇怪，直接使用英文就好) 构建： 感觉是为了将不同部分的信息联系起来 通过使用 图谱聚类算法（如 Leiden 算法），GraphRAG 会将不同的实体和关系分组，形成多个 社区（Community）。这些社区是根据实体之间的相似度或关系的密切程度进行划分的。这种分组帮助 GraphRAG 更好地理解不同知识领域的结构，</li></ul><h5 id="2-2-3-KAG"><a href="#2-2-3-KAG" class="headerlink" title="2.2.3 KAG"></a>2.2.3 KAG</h5><p><a href="https://github.com/OpenSPG/KAG/blob/master/README_cn.md">https://github.com/OpenSPG/KAG/blob/master/README_cn.md</a></p><h4 id="2-3-后处理"><a href="#2-3-后处理" class="headerlink" title="2.3 后处理"></a>2.3 后处理</h4><p>由于固定分块会破坏句子的连续性</p><h5 id="2-3-1-增加相邻上下文"><a href="#2-3-1-增加相邻上下文" class="headerlink" title="2.3.1 增加相邻上下文"></a>2.3.1 增加相邻上下文</h5><ul><li>在检索这一步时，将检索到的相邻chunk也包含进来以增加上下文，减少信息的损失</li></ul><h5 id="2-3-2-ReRank"><a href="#2-3-2-ReRank" class="headerlink" title="2.3.2 ReRank"></a>2.3.2 ReRank</h5><ul><li>ReRank<ul><li>就是觉得通过计算余弦相似度的方式得到的相似度具有一定的可信度，但是不高，因此使用其它方法对得到的top-k进行重排序，然后选择相关度最高的几个答案(一般使用LLM来实现)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at evaluating document relevance for search queries.</span></span><br><span class="line"><span class="string">Your task is to rate documents on a scale from 0 to 10 based on how well they answer the given query.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Guidelines:</span></span><br><span class="line"><span class="string">- Score 0-2: Document is completely irrelevant</span></span><br><span class="line"><span class="string">- Score 3-5: Document has some relevant information but doesn&#x27;t directly answer the query</span></span><br><span class="line"><span class="string">- Score 6-8: Document is relevant and partially answers the query</span></span><br><span class="line"><span class="string">- Score 9-10: Document is highly relevant and directly answers the query</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You MUST respond with ONLY a single integer score between 0 and 10. Do not include ANY other text.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>也可以使用关键词的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extract important keywords from the query</span></span><br><span class="line">keywords = [word.lower() <span class="keyword">for</span> word <span class="keyword">in</span> query.split() <span class="keyword">if</span> <span class="built_in">len</span>(word) &gt; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">scored_results = []  <span class="comment"># Initialize a list to store scored results</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    document_text = result[<span class="string">&quot;text&quot;</span>].lower()  <span class="comment"># Convert document text to lowercase</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base score starts with vector similarity</span></span><br><span class="line">    base_score = result[<span class="string">&quot;similarity&quot;</span>] * <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize keyword score</span></span><br><span class="line">    keyword_score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> keyword <span class="keyword">in</span> keywords:</span><br><span class="line">        <span class="keyword">if</span> keyword <span class="keyword">in</span> document_text:</span><br><span class="line">            <span class="comment"># Add points for each keyword found</span></span><br><span class="line">            keyword_score += <span class="number">0.1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Add more points if keyword appears near the beginning</span></span><br><span class="line">            first_position = document_text.find(keyword)</span><br><span class="line">            <span class="keyword">if</span> first_position &lt; <span class="built_in">len</span>(document_text) / <span class="number">4</span>:  <span class="comment"># In the first quarter of the text</span></span><br><span class="line">                keyword_score += <span class="number">0.1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Add points for keyword frequency</span></span><br><span class="line">            frequency = document_text.count(keyword)</span><br><span class="line">            keyword_score += <span class="built_in">min</span>(<span class="number">0.05</span> * frequency, <span class="number">0.2</span>)  <span class="comment"># Cap at 0.2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the final score by combining base score and keyword score</span></span><br><span class="line">    final_score = base_score + keyword_score</span><br></pre></td></tr></table></figure><h5 id="2-3-3-增加上下文-v2"><a href="#2-3-3-增加上下文-v2" class="headerlink" title="2.3.3 增加上下文-v2"></a>2.3.3 增加上下文-v2</h5><ul><li>计算连续chunk (分段)的总相关性，然后输出 top-k 个分段</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_best_segments</span>(<span class="params">chunk_values, max_segment_length=<span class="number">20</span>, total_max_length=<span class="number">30</span>, min_segment_value=<span class="number">0.2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Find the best segments using a variant of the maximum sum subarray algorithm.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        chunk_values (List[float]): Values for each chunk</span></span><br><span class="line"><span class="string">        max_segment_length (int): Maximum length of a single segment</span></span><br><span class="line"><span class="string">        total_max_length (int): Maximum total length across all segments</span></span><br><span class="line"><span class="string">        min_segment_value (float): Minimum value for a segment to be considered</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List[Tuple[int, int]]: List of (start, end) indices for best segments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finding optimal continuous text segments...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    best_segments = []</span><br><span class="line">    segment_scores = []</span><br><span class="line">    total_included_chunks = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Keep finding segments until we hit our limits</span></span><br><span class="line">    <span class="keyword">while</span> total_included_chunks &lt; total_max_length:</span><br><span class="line">        best_score = min_segment_value  <span class="comment"># Minimum threshold for a segment</span></span><br><span class="line">        best_segment = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Try each possible starting position</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chunk_values)):</span><br><span class="line">            <span class="comment"># Skip if this start position is already in a selected segment</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(start &gt;= s[<span class="number">0</span>] <span class="keyword">and</span> start &lt; s[<span class="number">1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> best_segments):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># Try each possible segment length</span></span><br><span class="line">            <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(max_segment_length, <span class="built_in">len</span>(chunk_values) - start) + <span class="number">1</span>):</span><br><span class="line">                end = start + length</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Skip if end position is already in a selected segment</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>(end &gt; s[<span class="number">0</span>] <span class="keyword">and</span> end &lt;= s[<span class="number">1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> best_segments):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Calculate segment value as sum of chunk values</span></span><br><span class="line">                segment_value = <span class="built_in">sum</span>(chunk_values[start:end])</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Update best segment if this one is better</span></span><br><span class="line">                <span class="keyword">if</span> segment_value &gt; best_score:</span><br><span class="line">                    best_score = segment_value</span><br><span class="line">                    best_segment = (start, end)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># If we found a good segment, add it</span></span><br><span class="line">        <span class="keyword">if</span> best_segment:</span><br><span class="line">            best_segments.append(best_segment)</span><br><span class="line">            segment_scores.append(best_score)</span><br><span class="line">            total_included_chunks += best_segment[<span class="number">1</span>] - best_segment[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found segment <span class="subst">&#123;best_segment&#125;</span> with score <span class="subst">&#123;best_score:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># No more good segments to find</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Sort segments by their starting position for readability</span></span><br><span class="line">    best_segments = <span class="built_in">sorted</span>(best_segments, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> best_segments, segment_scores</span><br></pre></td></tr></table></figure><h5 id="2-3-4-使用LLM过滤无效信息"><a href="#2-3-4-使用LLM过滤无效信息" class="headerlink" title="2.3.4 使用LLM过滤无效信息"></a>2.3.4 使用LLM过滤无效信息</h5><ul><li>使用LLM对top-k的chunk text进行判断，过滤，然后帮助我们筛选出最符合的信息，下面是实现的三种方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> compression_type == <span class="string">&quot;selective&quot;</span>:</span><br><span class="line">    system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at information filtering. </span></span><br><span class="line"><span class="string">    Your task is to analyze a document chunk and extract ONLY the sentences or paragraphs that are directly relevant to the user&#x27;s query. Remove all irrelevant content.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Your output should:</span></span><br><span class="line"><span class="string">    1. ONLY include text that helps answer the query</span></span><br><span class="line"><span class="string">    2. Preserve the exact wording of relevant sentences (do not paraphrase)</span></span><br><span class="line"><span class="string">    3. Maintain the original order of the text</span></span><br><span class="line"><span class="string">    4. Include ALL relevant content, even if it seems redundant</span></span><br><span class="line"><span class="string">    5. EXCLUDE any text that isn&#x27;t relevant to the query</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Format your response as plain text with no additional comments.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">elif</span> compression_type == <span class="string">&quot;summary&quot;</span>:</span><br><span class="line">    system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at summarization. </span></span><br><span class="line"><span class="string">    Your task is to create a concise summary of the provided chunk that focuses ONLY on information relevant to the user&#x27;s query.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Your output should:</span></span><br><span class="line"><span class="string">    1. Be brief but comprehensive regarding query-relevant information</span></span><br><span class="line"><span class="string">    2. Focus exclusively on information related to the query</span></span><br><span class="line"><span class="string">    3. Omit irrelevant details</span></span><br><span class="line"><span class="string">    4. Be written in a neutral, factual tone</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Format your response as plain text with no additional comments.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># extraction</span></span><br><span class="line">    system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at information extraction.</span></span><br><span class="line"><span class="string">    Your task is to extract ONLY the exact sentences from the document chunk that contain information relevant to answering the user&#x27;s query.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Your output should:</span></span><br><span class="line"><span class="string">    1. Include ONLY direct quotes of relevant sentences from the original text</span></span><br><span class="line"><span class="string">    2. Preserve the original wording (do not modify the text)</span></span><br><span class="line"><span class="string">    3. Include ONLY sentences that directly relate to the query</span></span><br><span class="line"><span class="string">    4. Separate extracted sentences with newlines</span></span><br><span class="line"><span class="string">    5. Do not add any commentary or additional text</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Format your response as plain text with no additional comments.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the query and document chunk</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Query: <span class="subst">&#123;query&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Document Chunk:</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;chunk&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Extract only the content relevant to answering this query.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-优化检索策略-Adaptive-Retrieval"><a href="#2-3-5-优化检索策略-Adaptive-Retrieval" class="headerlink" title="2.3.5 优化检索策略- Adaptive Retrieval"></a>2.3.5 优化检索策略- Adaptive Retrieval</h5><p>本质还是query的改写</p><p>RAG的效果差，也有可能是检索的策略有问题，对于所有的问题，全部采用向量相似度匹配，可能不太对，因此针对不同的用户问题，需要采取不同的策略</p><ul><li><strong>对查询类型进行分类: 事实、分析、观点或情境  （使用大模型来进行选择）</strong></li><li>然后 Query Transform （根据上面的类型进行改写）, 然后和之前一样进行相似度进行匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the system prompt to guide the AI&#x27;s classification</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at classifying questions. </span></span><br><span class="line"><span class="string">    Classify the given query into exactly one of these categories:</span></span><br><span class="line"><span class="string">    - Factual: Queries seeking specific, verifiable information.</span></span><br><span class="line"><span class="string">    - Analytical: Queries requiring comprehensive analysis or explanation.</span></span><br><span class="line"><span class="string">    - Opinion: Queries about subjective matters or seeking diverse viewpoints.</span></span><br><span class="line"><span class="string">    - Contextual: Queries that depend on user-specific context.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return ONLY the category name, without any explanation or additional text.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>query 改写的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################### 基于事实 Factual </span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at enhancing search queries.</span></span><br><span class="line"><span class="string">    Your task is to reformulate the given factual query to make it more precise and </span></span><br><span class="line"><span class="string">    specific for information retrieval. Focus on key entities and their relationships.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Provide ONLY the enhanced query without any explanation.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">user_prompt = <span class="string">f&quot;Enhance this factual query: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################### 基于事实 Factual </span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at enhancing search queries.</span></span><br><span class="line"><span class="string">    Your task is to reformulate the given factual query to make it more precise and </span></span><br><span class="line"><span class="string">    specific for information retrieval. Focus on key entities and their relationships.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Provide ONLY the enhanced query without any explanation.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">user_prompt = <span class="string">f&quot;Enhance this factual query: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基于分析 Analytical </span></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI in generating sub-questions</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at breaking down complex questions.</span></span><br><span class="line"><span class="string">Generate sub-questions that explore different aspects of the main analytical query.</span></span><br><span class="line"><span class="string">These sub-questions should cover the breadth of the topic and help retrieve </span></span><br><span class="line"><span class="string">comprehensive information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Return a list of exactly 3 sub-questions, one per line.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the user prompt with the main query</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Generate sub-questions for this analytical query: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##################  基于分析 Analytical </span></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI in generating sub-questions</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at breaking down complex questions.</span></span><br><span class="line"><span class="string">Generate sub-questions that explore different aspects of the main analytical query.</span></span><br><span class="line"><span class="string">These sub-questions should cover the breadth of the topic and help retrieve </span></span><br><span class="line"><span class="string">comprehensive information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Return a list of exactly 3 sub-questions, one per line.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the user prompt with the main query</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Generate sub-questions for this analytical query: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################## 基于观点 Opinion Strategy  </span></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI in identifying different perspectives</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at identifying different perspectives on a topic.</span></span><br><span class="line"><span class="string">    For the given query about opinions or viewpoints, identify different perspectives </span></span><br><span class="line"><span class="string">    that people might have on this topic.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return a list of exactly 3 different viewpoint angles, one per line.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the user prompt with the main query</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Identify different perspectives on: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract and clean the viewpoints</span></span><br><span class="line">viewpoints = response.choices[<span class="number">0</span>].message.content.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">viewpoints = [v.strip() <span class="keyword">for</span> v <span class="keyword">in</span> viewpoints <span class="keyword">if</span> v.strip()]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Identified viewpoints: <span class="subst">&#123;viewpoints&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve documents representing each viewpoint</span></span><br><span class="line">all_results = []</span><br><span class="line"><span class="keyword">for</span> viewpoint <span class="keyword">in</span> viewpoints:</span><br><span class="line">    <span class="comment"># 注意这里的做法</span></span><br><span class="line">    <span class="comment"># Combine the main query with the viewpoint</span></span><br><span class="line">    combined_query = <span class="string">f&quot;<span class="subst">&#123;query&#125;</span> <span class="subst">&#123;viewpoint&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># Create embeddings for the combined query</span></span><br><span class="line">    viewpoint_embedding = create_embeddings(combined_query)</span><br><span class="line">    <span class="comment"># Perform similarity search for the combined query</span></span><br><span class="line">    results = vector_store.similarity_search(viewpoint_embedding, k=<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Mark results with the viewpoint they represent</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        result[<span class="string">&quot;viewpoint&quot;</span>] = viewpoint</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Add the results to the list of all results</span></span><br><span class="line">    all_results.extend(results)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">################### 基于情境  Contextual Strategy</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> user_context:</span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at understanding implied context in questions.</span></span><br><span class="line"><span class="string">For the given query, infer what contextual information might be relevant or implied </span></span><br><span class="line"><span class="string">but not explicitly stated. Focus on what background would help answering this query.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Return a brief description of the implied context.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">user_prompt = <span class="string">f&quot;Infer the implied context in this query: <span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the inferred context using the LLM</span></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;meta-llama/Llama-3.2-3B-Instruct&quot;</span>,</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_prompt&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_prompt&#125;</span><br><span class="line">    ],</span><br><span class="line">    temperature=<span class="number">0.1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract and print the inferred context</span></span><br><span class="line">user_context = response.choices[<span class="number">0</span>].message.content.strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Inferred context: <span class="subst">&#123;user_context&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reformulate the query to incorporate context</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an expert at reformulating questions with context.</span></span><br><span class="line"><span class="string">Given a query and some contextual information, create a more specific query that </span></span><br><span class="line"><span class="string">incorporates the context to get more relevant information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Return ONLY the reformulated query without explanation.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Query: <span class="subst">&#123;query&#125;</span></span></span><br><span class="line"><span class="string">Context: <span class="subst">&#123;user_context&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reformulate the query to incorporate this context:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the contextualized query using the LLM</span></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=<span class="string">&quot;meta-llama/Llama-3.2-3B-Instruct&quot;</span>,</span><br><span class="line">messages=[</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_prompt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_prompt&#125;</span><br><span class="line">],</span><br><span class="line">temperature=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h5 id="2-3-6-CRAG"><a href="#2-3-6-CRAG" class="headerlink" title="2.3.6 CRAG"></a>2.3.6 CRAG</h5><p><strong>对检索的文件进行了修正</strong></p><p>校验检索得到的文档，如果文档相关性评分比较高(相关性分数还是使用LLM)，那么继续原先的步骤即可；如果相关性评分很低，那么采用外部的工具(如浏览器等)来搜索更多的资料，用以补充；如果相关性评分在中间，结合检索文本和搜索文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crag_process</span>(<span class="params">query, vector_store, k=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n=== Processing query with CRAG: <span class="subst">&#123;query&#125;</span> ===\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 1: Create query embedding and retrieve documents</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Retrieving initial documents...&quot;</span>)</span><br><span class="line">    query_embedding = create_embeddings(query)</span><br><span class="line">    retrieved_docs = vector_store.similarity_search(query_embedding, k=k)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 2: Evaluate document relevance</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Evaluating document relevance...&quot;</span>)</span><br><span class="line">    relevance_scores = []</span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> retrieved_docs:</span><br><span class="line">        score = evaluate_document_relevance(query, doc[<span class="string">&quot;text&quot;</span>])</span><br><span class="line">        relevance_scores.append(score)</span><br><span class="line">        doc[<span class="string">&quot;relevance&quot;</span>] = score</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Document scored <span class="subst">&#123;score:<span class="number">.2</span>f&#125;</span> relevance&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 3: Determine action based on best relevance score</span></span><br><span class="line">    max_score = <span class="built_in">max</span>(relevance_scores) <span class="keyword">if</span> relevance_scores <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    best_doc_idx = relevance_scores.index(max_score) <span class="keyword">if</span> relevance_scores <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Track sources for attribution</span></span><br><span class="line">    sources = []</span><br><span class="line">    final_knowledge = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 4: Execute the appropriate knowledge acquisition strategy</span></span><br><span class="line">    <span class="keyword">if</span> max_score &gt; <span class="number">0.7</span>:</span><br><span class="line">        <span class="comment"># Case 1: High relevance - Use document directly</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;High relevance (<span class="subst">&#123;max_score:<span class="number">.2</span>f&#125;</span>) - Using document directly&quot;</span>)</span><br><span class="line">        best_doc = retrieved_docs[best_doc_idx][<span class="string">&quot;text&quot;</span>]</span><br><span class="line">        final_knowledge = best_doc</span><br><span class="line">        sources.append(&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Document&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">elif</span> max_score &lt; <span class="number">0.3</span>:</span><br><span class="line">        <span class="comment"># Case 2: Low relevance - Use web search</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Low relevance (<span class="subst">&#123;max_score:<span class="number">.2</span>f&#125;</span>) - Performing web search&quot;</span>)</span><br><span class="line">        web_results, web_sources = perform_web_search(query)</span><br><span class="line">        final_knowledge = refine_knowledge(web_results)</span><br><span class="line">        sources.extend(web_sources)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Case 3: Medium relevance - Combine document with web search</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Medium relevance (<span class="subst">&#123;max_score:<span class="number">.2</span>f&#125;</span>) - Combining document with web search&quot;</span>)</span><br><span class="line">        best_doc = retrieved_docs[best_doc_idx][<span class="string">&quot;text&quot;</span>]</span><br><span class="line">        refined_doc = refine_knowledge(best_doc)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get web results</span></span><br><span class="line">        web_results, web_sources = perform_web_search(query)</span><br><span class="line">        refined_web = refine_knowledge(web_results)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Combine knowledge</span></span><br><span class="line">        final_knowledge = <span class="string">f&quot;From document:\n<span class="subst">&#123;refined_doc&#125;</span>\n\nFrom web search:\n<span class="subst">&#123;refined_web&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add sources</span></span><br><span class="line">        sources.append(&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Document&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        sources.extend(web_sources)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 5: Generate final response</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generating final response...&quot;</span>)</span><br><span class="line">    response = generate_response(query, final_knowledge, sources)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Return comprehensive results</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: query,</span><br><span class="line">        <span class="string">&quot;response&quot;</span>: response,</span><br><span class="line">        <span class="string">&quot;retrieved_docs&quot;</span>: retrieved_docs,</span><br><span class="line">        <span class="string">&quot;relevance_scores&quot;</span>: relevance_scores,</span><br><span class="line">        <span class="string">&quot;max_relevance&quot;</span>: max_score,</span><br><span class="line">        <span class="string">&quot;final_knowledge&quot;</span>: final_knowledge,</span><br><span class="line">        <span class="string">&quot;sources&quot;</span>: sources</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-输入部分"><a href="#2-4-输入部分" class="headerlink" title="2.4 输入部分"></a>2.4 输入部分</h4><h5 id="2-4-1-Query-Transform"><a href="#2-4-1-Query-Transform" class="headerlink" title="2.4.1 Query Transform"></a>2.4.1 Query Transform</h5><ul><li><p>Query改写</p><p>可能是觉得用户提的问题不够具体，导致搜索的时候找到对应的信息；亦或者是用户的问题太复杂了，包含了很多层级的问题；亦或者是用户的问题太细致了，以至匹配不到相关的信息，需要对信息step back；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############ 1.Query Rewriting </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI assistant&#x27;s behavior</span></span><br><span class="line">system_prompt = <span class="string">&quot;You are an AI assistant specialized in improving search queries. Your task is to rewrite user queries to be more specific, detailed, and likely to retrieve relevant information.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the original query to be rewritten</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Rewrite the following query to make it more specific and detailed. Include relevant terms and concepts that might help in retrieving accurate information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Original query: <span class="subst">&#123;original_query&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Rewritten query:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ 2. Step-back Prompting</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI assistant&#x27;s behavior</span></span><br><span class="line">system_prompt = <span class="string">&quot;You are an AI assistant specialized in search strategies. Your task is to generate broader, more general versions of specific queries to retrieve relevant background information.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the original query to be generalized</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Generate a broader, more general version of the following query that could help retrieve useful background information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Original query: <span class="subst">&#123;original_query&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Step-back query:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############ 3. Sub-query Decomposition</span></span><br><span class="line"><span class="comment"># Define the system prompt to guide the AI assistant&#x27;s behavior</span></span><br><span class="line">system_prompt = <span class="string">&quot;You are an AI assistant specialized in breaking down complex questions. Your task is to decompose complex queries into simpler sub-questions that, when answered together, address the original query.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the original query to be decomposed</span></span><br><span class="line">user_prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Break down the following complex query into <span class="subst">&#123;num_subqueries&#125;</span> simpler sub-queries. Each sub-query should focus on a different aspect of the original question.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Original query: <span class="subst">&#123;original_query&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Generate <span class="subst">&#123;num_subqueries&#125;</span> sub-queries, one per line, in this format:</span></span><br><span class="line"><span class="string">1. [First sub-query]</span></span><br><span class="line"><span class="string">2. [Second sub-query]</span></span><br><span class="line"><span class="string">And so on...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-2-HyDE-Hypothetical-Document-Embedding"><a href="#2-4-2-HyDE-Hypothetical-Document-Embedding" class="headerlink" title="2.4.2 HyDE (Hypothetical Document Embedding)"></a>2.4.2 HyDE (Hypothetical Document Embedding)</h5><p> 本质上还是Query改写的一种，具体操作方法如下：</p><ul><li>根据用户的问题，假想一个document，这个document可以解决用户的query； (这里使用的还是LLM)</li><li>然后使用这个document进行向量化和相似度的比较，继续后面的流程；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the system prompt to instruct the model on how to generate the document</span></span><br><span class="line">system_prompt = <span class="string">f&quot;&quot;&quot;You are an expert document creator. </span></span><br><span class="line"><span class="string">Given a question, generate a detailed document that would directly answer this question.</span></span><br><span class="line"><span class="string">The document should be approximately <span class="subst">&#123;desired_length&#125;</span> characters long and provide an in-depth, </span></span><br><span class="line"><span class="string">informative answer to the question. Write as if this document is from an authoritative source</span></span><br><span class="line"><span class="string">on the subject. Include specific details, facts, and explanations.</span></span><br><span class="line"><span class="string">Do not mention that this is a hypothetical document - just write the content directly.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the user prompt with the query</span></span><br><span class="line">user_prompt = <span class="string">f&quot;Question: <span class="subst">&#123;query&#125;</span>\n\nGenerate a document that fully answers this question:&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Rag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>langgraph官方文档学习</title>
      <link href="/2025/04/08/langgraph%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/08/langgraph%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>顺序可能不按照官方文档的顺序，按照自己感兴趣的模块，然后通过demo 代码的方式来理解这个模块的用法</p><h3 id="subgraph"><a href="#subgraph" class="headerlink" title="subgraph"></a>subgraph</h3><p>在langgraph里面，可以通过两种方式将subgraph添加到 流程中</p><ul><li>通过工具调用的方式引入 (invoke a graph from a node)</li></ul><p>例如下面的官方例子中，subgraph通过主流程中call_subgraph这个tools函数来触发subgraph的调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing_extensions <span class="keyword">import</span> TypedDict</span><br><span class="line"><span class="keyword">from</span> langgraph.graph.state <span class="keyword">import</span> StateGraph, START</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubgraphState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    bar: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Subgraph</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subgraph_node_1</span>(<span class="params">state: SubgraphState</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;bar&quot;</span>: <span class="string">&quot;hi! &quot;</span> + state[<span class="string">&quot;bar&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">subgraph_builder = StateGraph(SubgraphState)</span><br><span class="line">subgraph_builder.add_node(subgraph_node_1)</span><br><span class="line">subgraph_builder.add_edge(START, <span class="string">&quot;subgraph_node_1&quot;</span>)</span><br><span class="line">subgraph = subgraph_builder.<span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parent graph</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    foo: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_subgraph</span>(<span class="params">state: State</span>):   </span><br><span class="line">    <span class="comment"># Transform the state to the subgraph state</span></span><br><span class="line">    subgraph_output = subgraph.invoke(&#123;<span class="string">&quot;bar&quot;</span>: state[<span class="string">&quot;foo&quot;</span>]&#125;)  </span><br><span class="line">    <span class="comment"># Transform response back to the parent state</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;foo&quot;</span>: subgraph_output[<span class="string">&quot;bar&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">builder = StateGraph(State)</span><br><span class="line">builder.add_node(<span class="string">&quot;node_1&quot;</span>, call_subgraph)</span><br><span class="line">builder.add_edge(START, <span class="string">&quot;node_1&quot;</span>)</span><br><span class="line">graph = builder.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure><ul><li>直接以子节点的方式添加到流程中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing_extensions <span class="keyword">import</span> TypedDict</span><br><span class="line"><span class="keyword">from</span> langgraph.graph.state <span class="keyword">import</span> StateGraph, START</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    foo: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Subgraph</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subgraph_node_1</span>(<span class="params">state: State</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;hi! &quot;</span> + state[<span class="string">&quot;foo&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">subgraph_builder = StateGraph(State)</span><br><span class="line">subgraph_builder.add_node(subgraph_node_1)</span><br><span class="line">subgraph_builder.add_edge(START, <span class="string">&quot;subgraph_node_1&quot;</span>)</span><br><span class="line">subgraph = subgraph_builder.<span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parent graph</span></span><br><span class="line"></span><br><span class="line">builder = StateGraph(State)</span><br><span class="line">builder.add_node(<span class="string">&quot;node_1&quot;</span>, subgraph)  </span><br><span class="line">builder.add_edge(START, <span class="string">&quot;node_1&quot;</span>)</span><br><span class="line">graph = builder.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure><p><strong>通过传参也可以看到，子节点的方式，subgraph共享主graph的State</strong></p><h3 id="human-in-loop"><a href="#human-in-loop" class="headerlink" title="human in loop"></a>human in loop</h3><h3 id="可学习资料"><a href="#可学习资料" class="headerlink" title="可学习资料"></a>可学习资料</h3><p>1.<a href="https://mp.weixin.qq.com/s/XhFbLTLcSjDj0r3KGT9EOg">Multi-Agent全面爆发！一文详解多智能体核心架构及LangGraph框架</a><br>2.<a href="https://mp.weixin.qq.com/s/m37YhDsKsQn2HWuV7LKwgg">破除AI Agent自主操控风险：万字解读LangGraph“人工干预”机制 ，附零基础实战</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Agent </tag>
            
            <tag> langgraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphRAG</title>
      <link href="/2025/03/13/GraphRAG/"/>
      <url>/2025/03/13/GraphRAG/</url>
      
        <content type="html"><![CDATA[<h2 id="1-why-we-need-GraphRAG"><a href="#1-why-we-need-GraphRAG" class="headerlink" title="1. why we need GraphRAG?"></a>1. why we need GraphRAG?</h2><blockquote><p><a href="https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/">https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/</a></p></blockquote><ul><li>基本的RAG 难以建立信息关联。当回答某个问题需要遍历不同信息片段并通过其共享属性来提供新的综合见解时，就会出现这种情况。</li><li>基本RAG 在被要求整体理解大型数据集合甚至单个大型文档中的汇总语义概念时表现不佳。</li></ul><blockquote><p>我想到的一个例子是：假设我有一个介绍 LLM的文章，然后分段式介绍了LLM的一些特点(假设每一段不显式的包含LLM信息，用它，他或者其他代词指代)，然后这些信息被分别分块，然后embedding，在query (问LLM的优点， 需要根据LLM的特点来总结)，search的时候，应该就不会查到这些信息。</p></blockquote><h2 id="2-GraphRAG的原理"><a href="#2-GraphRAG的原理" class="headerlink" title="2. GraphRAG的原理"></a>2. GraphRAG的原理</h2><h3 id="2-1-构建阶段"><a href="#2-1-构建阶段" class="headerlink" title="2.1 构建阶段"></a>2.1 构建阶段</h3><p><strong>在建立索引</strong>(index)这一步，主要按照下面的步骤进行：</p><ul><li>将输入语料库分割为一系列的文本单元（TextUnits），这些单元作为处理以下步骤的可分析单元，并在我们的输出中提供细粒度的引用。</li><li>使用 LLM 从文本单元中提取所有实体、关系和关键声明。并且对每个实体，关系，文本生成embedding向量</li><li>使用 Leiden 技术 对知识图谱进行层次聚类。</li><li>GraphRAG通过计算实体之间的关系，填充关系表，并生成关于实体的社区报告来总结不同实体之间的关系与上下文，自下而上地生成每个社区层级及其组成部分的摘要。这有助于对数据集的整体理解。</li></ul><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251128104304468.png" alt="image-20251128104304468"  /><blockquote><p>具体的例子可以参考这篇知乎文章的例子: <a href="https://zhuanlan.zhihu.com/p/13801755777">GraphRAG快速入门与原理详解</a></p></blockquote><h3 id="2-1-查询阶段"><a href="#2-1-查询阶段" class="headerlink" title="2.1 查询阶段"></a>2.1 查询阶段</h3><p><strong>在查询这一步</strong>，又分为两种方式：</p><ul><li>全局搜索，用于通过利用社区层级摘要来推理有关语料库的整体问题。</li><li>局部搜索，用于通过扩展到其邻居和相关概念来推理特定实体的情况。</li></ul><h4 id="局部搜索"><a href="#局部搜索" class="headerlink" title="局部搜索"></a>局部搜索</h4><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251128140852857.png" alt="image-20251128140852857"></p><p>有点类似BM25关键词搜索，然后找到一些相关的实体关系之后，然后再利用图谱的节点关系再在领近查找更多信息，然后再汇总</p><h4 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h4><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-20251128141135147.png" alt="image-20251128141135147"></p><p>根据用户的问题，全局搜索会搜索相关的社区报告 ，并且给每一个社区报告打分(<strong>使用LLM来进行</strong>)，根据打分的高低，然后将最相关的社区报告给到大模型的上下文中；</p><h2 id="3-项目源码学习"><a href="#3-项目源码学习" class="headerlink" title="3. 项目源码学习"></a>3. 项目源码学习</h2><ul><li><input disabled="" type="checkbox"> TODO</li></ul>]]></content>
      
      
      <categories>
          
          <category> RAG框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader介绍</title>
      <link href="/2023/05/14/shader%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/05/14/shader%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="shader基本用法总结"><a href="#shader基本用法总结" class="headerlink" title="shader基本用法总结"></a>shader基本用法总结</h2><span id="more"></span><h3 id="1-Shader-基本介绍"><a href="#1-Shader-基本介绍" class="headerlink" title="1. Shader 基本介绍"></a>1. Shader 基本介绍</h3><p>首先需要认识到的一点是，shader是运行在GPU上的，天然的<strong>并行处理</strong></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.4ooooia27cs0.webp" alt="image"></p><p>我们通过编写代码(即shader），<strong>来‘点亮’下面画布中的每个像素</strong>！</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.6mwney17yqk0.webp" alt="image"></p><p>右边列出这么长的公式不是为了劝退大家，它都是由基本图形公式组合而来（后面我会给大家进行讲解），理解了就容易，但是一下子放在这里就很难理解，所以大家在写shader复合效果代码时，<strong>一定要写注释说明</strong>，不然后面优化维护的同学是真的难受😭</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create 100x100 cell sheet</span></span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">floor</span>(<span class="number">100.0</span>*(<span class="number">0.5</span>+(fragCoord.x<span class="number">-0.5</span>*iResolution.x)/iResolution.y));</span><br><span class="line">    <span class="type">float</span> r = <span class="built_in">floor</span>(<span class="number">100.0</span>*(<span class="number">1.0</span>-fragCoord.y/iResolution.y));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// paint flower</span></span><br><span class="line">    <span class="type">float</span> f = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">20.0</span>+<span class="number">20.0</span>*(<span class="built_in">pow</span>(<span class="number">0.5</span>+<span class="number">0.5</span>*<span class="built_in">cos</span>(<span class="number">5.0</span>*<span class="built_in">atan</span>(r<span class="number">-50.5</span>,c<span class="number">-50.5</span>)),<span class="number">0.3</span>))-<span class="built_in">sqrt</span>((c<span class="number">-50.5</span>)*(c<span class="number">-50.5</span>)+(r<span class="number">-50.5</span>)*(r<span class="number">-50.5</span>)),<span class="number">0.0</span>),<span class="number">1.0</span>);</span><br><span class="line">    f += <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">19.0</span>-<span class="built_in">sqrt</span>((c<span class="number">-50.5</span>)*(c<span class="number">-50.5</span>)+(r<span class="number">-50.5</span>)*(r<span class="number">-50.5</span>)),<span class="number">0.0</span>),<span class="number">1.0</span>);</span><br><span class="line">    f -= <span class="number">2.0</span>*<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">46.0</span>-r,<span class="number">0.0</span>),<span class="number">1.0</span>)*<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">2.0</span>-<span class="built_in">abs</span>(<span class="number">4.0</span>-<span class="built_in">sqrt</span>( <span class="built_in">pow</span>(<span class="built_in">abs</span>(r<span class="number">-45.0</span>),<span class="number">2.0</span>)+<span class="built_in">pow</span>(<span class="built_in">abs</span>(<span class="built_in">abs</span>(c<span class="number">-50.5</span>)<span class="number">-6.0</span>),<span class="number">2.0</span>))),<span class="number">0.0</span>),<span class="number">1.0</span>);</span><br><span class="line">    f -= <span class="number">2.0</span>*<span class="built_in">min</span>(<span class="built_in">max</span>(r<span class="number">-50.</span>  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="number">0</span>,<span class="number">0.0</span>),<span class="number">1.0</span>)*<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">2.0</span>-<span class="built_in">abs</span>(<span class="number">8.0</span>-<span class="built_in">sqrt</span>((c<span class="number">-50.5</span>)*(c<span class="number">-50.5</span>)+(r<span class="number">-50.5</span>)*(r<span class="number">-50.5</span>))),<span class="number">0.0</span>),<span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// colorize</span></span><br><span class="line">    <span class="type">vec3</span> h = (f&lt;<span class="number">1.0</span>) ? <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">0.44</span>,<span class="number">0.66</span>,<span class="number">0.86</span>),<span class="type">vec3</span>(<span class="number">1</span>),f) :</span><br><span class="line">                       <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">1</span>), <span class="type">vec3</span>(<span class="number">1</span>,<span class="number">0.85</span>,<span class="number">0.4</span>),f<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(h,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-how-to-write-a-shader"><a href="#1-1-how-to-write-a-shader" class="headerlink" title="1.1 how to write a shader ?"></a>1.1 how to write a shader ?</h4><ul><li><p><strong>我们在哪儿作画？</strong></p><ul><li><a href="https://www.shadertoy.com/new">https://www.shadertoy.com/new</a></li><li>VS Code 插件shadertoy, 使用方法也比较简单</li></ul></li><li><p><strong>一些基本知识介绍</strong></p></li><li><p>从哪儿开始呢？画一个三角形貌似有点难(PS：图形学中的hello world就是绘制一个三角形🔼)，那就从点亮屏幕开始吧 ！</p></li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shader具有一些内置函数：</span></span><br><span class="line"><span class="comment">//     iResolution :  画布的精度，宽高参数</span></span><br><span class="line"><span class="comment">//     iTime       :  时间参数，让效果动起来</span></span><br><span class="line"><span class="comment">//     iMouse      :  鼠标操作，交互设计</span></span><br><span class="line"><span class="comment">//     工具函数     :  sin, cos, pow, mod, smoothstep, floor等</span></span><br><span class="line"> <span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 将画布归一化到0.0到1.0之间</span></span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//           输出颜色，即对应uv下的颜色值</span></span><br><span class="line">    <span class="comment">//                r     g    b   a</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对应图2</span></span><br><span class="line">    <span class="comment">// fragColor = vec4(uv.x, 0.0, 0.0, 1.0);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对应图3</span></span><br><span class="line">    <span class="comment">// vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); </span></span><br><span class="line">    <span class="comment">// fragColor = vec4(color, 1.0);</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.3yl1khhw3b00.webp" alt="image" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.6d2rqxyrgq00.webp" alt="image"><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/c0afb7c7-ad91-427b-878a-d7967a5d15d3.2dxd0t8qnz40.gif" alt="c0afb7c7-ad91-427b-878a-d7967a5d15d3" style="zoom:40%;" /></p><p>​                    图一                                                         图二                                                             图三</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.19yzzfokpbr4.webp" alt="image"></p><h4 id="1-2-generative-art"><a href="#1-2-generative-art" class="headerlink" title="1.2 generative art"></a>1.2 generative art</h4><h5 id="1-2-1-形状"><a href="#1-2-1-形状" class="headerlink" title="1.2.1 形状"></a>1.2.1 形状</h5><ul><li><strong>善于使用step 和smoothstep函数</strong></li></ul><p>​     <a href="https://thebookofshaders.com/glossary/?search=step"> step 函数</a>：一般用来作截断处理</p><p>​      <a href="https://thebookofshaders.com/glossary/?search=smoothstep">smoothstep函数</a>：一般用来做平滑处理，smoothstep函数可以替代step函数（参数1等于参数2，或者接近时，可以理解为step函数）</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line">    uv = uv - <span class="number">0.5</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.7</span>, <span class="number">0.4</span>, <span class="number">0.6</span>);</span><br><span class="line">    <span class="keyword">if</span> (uv.x &lt; <span class="number">-.3</span> &amp;&amp; uv.y &gt;<span class="number">0.1</span>)</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">0.7</span>, <span class="number">0.0</span>, <span class="number">.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (uv.x &gt; <span class="number">0.2</span> &amp;&amp; uv.y &lt; <span class="number">-0.4</span>)</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (uv.x &gt; <span class="number">0.4</span> &amp;&amp; uv.y &gt; <span class="number">0.1</span>)</span><br><span class="line">        color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.6</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.01</span>;</span><br><span class="line">    color *= <span class="built_in">step</span>(r, <span class="built_in">abs</span>(uv.x + <span class="number">0.3</span>));</span><br><span class="line">    color *= <span class="built_in">step</span>(r, <span class="built_in">abs</span>(uv.x - <span class="number">0.2</span>));</span><br><span class="line">    color *= <span class="built_in">step</span>(r, <span class="built_in">abs</span>(uv.x - <span class="number">0.4</span>));</span><br><span class="line">    color *= <span class="number">1.0</span> -(<span class="number">1.0</span> - <span class="built_in">step</span>(r, <span class="built_in">abs</span>(uv.x + <span class="number">0.4</span>))) * (<span class="built_in">smoothstep</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, uv.y));</span><br><span class="line">    color *= <span class="built_in">step</span>(r * <span class="number">2.</span>, <span class="built_in">abs</span>(uv.y - <span class="number">0.1</span>));</span><br><span class="line">    color *= <span class="built_in">step</span>(r * <span class="number">2.</span>, <span class="built_in">abs</span>(uv.y - <span class="number">0.3</span>));</span><br><span class="line">    color *= <span class="number">1.0</span> - (<span class="number">1.0</span> - <span class="built_in">step</span>(r * <span class="number">2.</span>, <span class="built_in">abs</span>(uv.y + <span class="number">0.4</span>))) * <span class="built_in">smoothstep</span>(<span class="number">-0.3</span>, <span class="number">-0.3</span>, uv.x);     </span><br><span class="line">   </span><br><span class="line">    fragColor = <span class="type">vec4</span>(color,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.5hxd4298hjg0.webp" alt="image" style="zoom:80%;" />                                     <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.68rou7uosh40.webp" alt="image">  </p><p>​              参考示意图                                                                                            运行代码图</p><ul><li><strong>SDF(符号距离场）</strong></li></ul><blockquote><p>详细可参考文档<a href="https://quvideo.feishu.cn/docs/doccnhRzxWM8QLgecBYUCFik30c">Signed Distance Field</a> </p></blockquote><p>在这一部分，使用最频繁的函数是 length(), 其它具有同样功能的有sqrt(),distance()</p><p>这里主要是掌握距离场这种思想！！！</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    <span class="comment">// 将坐标原点移到中心</span></span><br><span class="line">    uv = uv - <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 保持原来的长宽比</span></span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前像素到原点的距离</span></span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置比较对象，这里即圆的半径</span></span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.3</span>;</span><br><span class="line">    color *= <span class="built_in">smoothstep</span>(r, r + <span class="number">0.01</span>, d);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>如果没有保持长宽比的话，可能显示的是一个椭圆，因为图形被拉伸了！</strong></li><li>这里的smoothstep这一行可以理解为：小于r，返回0.0值，color乘以0.0等于0.0，显示黑色；大于r，则返回1.0.保持color值，既保持背景色</li></ol><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.2mnd30zvrw80.webp" alt="image"></p><p>​                                                                                         结果图</p><ul><li><strong>极坐标</strong></li></ul><p>​         这一方面主要用来生成齿轮，花瓣等沿着圆周变化的形状，因为是以角度为自变量，所以atan()函数基本上一定会用到(当我们看到别人的shader里面有atan函数时，可以往角度方向去想一下)</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    <span class="comment">// 将坐标原点移到中心</span></span><br><span class="line">    uv = uv - <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 保持原来的长宽比</span></span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前像素到原点的距离</span></span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****************   added  *************</span></span><br><span class="line">    <span class="comment">// 设置比较对象，这里添加角度的变化项</span></span><br><span class="line">    r = <span class="number">0.3</span> + <span class="number">0.1</span> * <span class="built_in">cos</span>(<span class="number">6.0</span> * <span class="built_in">atan</span>(uv.y, uv.x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对应第二个图</span></span><br><span class="line">    <span class="comment">// r = 0.3 + 0.1 * abs(cos(6.0 * atan(uv.y, uv.x)));</span></span><br><span class="line">    <span class="comment">// 对应第三个图</span></span><br><span class="line">    <span class="comment">// r = 0.3 + 0.1 * smoothstep(-.5, 0.4, cos(8.0 * atan(uv.y, uv.x)));</span></span><br><span class="line">    <span class="comment">// ****************   added  *************</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    color *= <span class="built_in">smoothstep</span>(r, r + <span class="number">0.01</span>, d);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.4r38h4j83720.webp" alt="image" style="zoom:67%;" />   <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.25hsp6rmak80.webp" alt="image" style="zoom:67%;" />     <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.6l552wxuyp00.webp" alt="image" style="zoom:67%;" /></p><p>​                 图一                                                   图二                                                      图三</p><h5 id="1-2-2-图形的基本操作"><a href="#1-2-2-图形的基本操作" class="headerlink" title="1.2.2 图形的基本操作"></a>1.2.2 图形的基本操作</h5><p>主要包括平移，旋转，缩放</p><p>旋转矩阵</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.1iy25plo5nvk.webp" alt="image"></p><p><strong>注意：</strong></p><p>​        缩放，旋转是有参考点的，下面的两个矩阵都是针对原点进行计算的，如果不在原点，需要先平移到原点，然后进行旋转，缩放操作，然后再平移到原先的位置。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转矩阵</span></span><br><span class="line"><span class="type">mat2</span> rotate2d(<span class="type">float</span> _angle)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">mat2</span>(<span class="built_in">cos</span>(_angle),-<span class="built_in">sin</span>(_angle),</span><br><span class="line">                <span class="built_in">sin</span>(_angle),<span class="built_in">cos</span>(_angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放矩阵</span></span><br><span class="line"><span class="type">mat2</span> scale(<span class="type">vec2</span> _scale)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">mat2</span>(_scale.x,<span class="number">0.0</span>,</span><br><span class="line">                <span class="number">0.0</span>,_scale.y);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    <span class="comment">// 将坐标原点移到中心</span></span><br><span class="line">    uv = uv - <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 保持原来的长宽比</span></span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****************   added  *************</span></span><br><span class="line">    <span class="comment">// 平移</span></span><br><span class="line">    uv += (<span class="built_in">sin</span>(iTime), <span class="built_in">cos</span>(iTime)) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    <span class="comment">// uv *= rotate2d( sin(iTime)*PI );</span></span><br><span class="line">    <span class="comment">// 缩放</span></span><br><span class="line">    <span class="comment">// uv *= scale( vec2(0.8 + abs(sin(iTime)) * 0.5) );</span></span><br><span class="line">    <span class="comment">// ****************   added  *************</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前像素到原点的距离</span></span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0</span>;</span><br><span class="line">    r = <span class="number">0.3</span> + <span class="number">0.1</span> * <span class="built_in">smoothstep</span>(<span class="number">-.5</span>, <span class="number">0.4</span>, <span class="built_in">cos</span>(<span class="number">8.0</span> * <span class="built_in">atan</span>(uv.y, uv.x)));</span><br><span class="line">    color *= <span class="built_in">smoothstep</span>(r, r + <span class="number">0.01</span>, d);</span><br><span class="line">   </span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/1.58bk40zkisw0.gif" alt="1" style="zoom: 33%;" />               <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/2.43s81uxpc900.gif" alt="2" style="zoom:33%;" />              <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/3.2970omykd3gg.gif" alt="3" style="zoom:33%;" />  </p><p>​            图一                                                                图二                                                           图三</p><h5 id="1-2-3-重复，分形"><a href="#1-2-3-重复，分形" class="headerlink" title="1.2.3 重复，分形"></a>1.2.3 重复，分形</h5><ul><li><strong>重复</strong></li></ul><p>​        如果我们绘制多个相同的图案，那么可以采取下面的想法：我们的画布是归一化到0.0到1.0，如果我们将画布划分若干份，然后将每一部分的坐标重新映射到0.0到1.0，那么我们在一个画布上绘制的图案就会被同步到其它区域上，从而实现了重复图形的绘制。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ****************   added  *************</span></span><br><span class="line">    <span class="comment">// 实现重复部分的代码    </span></span><br><span class="line">    uv = uv * <span class="number">3.0</span>;</span><br><span class="line">    uv = <span class="built_in">fract</span>(uv);</span><br><span class="line">    <span class="comment">// ****************   added  *************  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将坐标原点移到中心</span></span><br><span class="line">    uv = uv - <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 保持原来的长宽比</span></span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前像素到原点的距离</span></span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> r = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    r = <span class="number">0.3</span> + <span class="number">0.1</span> * <span class="built_in">smoothstep</span>(<span class="number">-.5</span>, <span class="number">0.4</span>, <span class="built_in">cos</span>(<span class="number">8.0</span> * <span class="built_in">atan</span>(uv.y, uv.x)));</span><br><span class="line">    </span><br><span class="line">    color *= <span class="built_in">smoothstep</span>(r, r + <span class="number">0.01</span>, d);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.28tbyxrx6tus.webp" alt="image"></p><ul><li><strong>分形</strong></li></ul><p>主要用于模拟树木，山脉，树叶等等具有自相似的物体</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">vec2</span> complex_sqr(<span class="type">vec2</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec2</span>(<span class="built_in">pow</span>(pos.x, <span class="number">2.0</span>) - <span class="built_in">pow</span>(pos.y, <span class="number">2.0</span>), pos.x * pos.y * <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> c = <span class="type">vec2</span>(<span class="number">-0.8</span>, <span class="built_in">cos</span>(iTime) * <span class="number">0.2</span>);</span><br><span class="line">    <span class="type">vec2</span> z = <span class="type">vec2</span>(uv.x * <span class="number">2.0</span> - <span class="number">1.0</span>, uv.y - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> iterations = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">length</span>(z) &lt; <span class="number">20.</span> &amp;&amp; iterations &lt; <span class="number">50.</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        z = complex_sqr(z) + c;</span><br><span class="line">        iterations += <span class="number">1.</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> col = <span class="type">vec3</span>(<span class="number">1.</span> - iterations * <span class="number">0.02</span>);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="type">vec4</span>(col,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/4.10eklxiyfou8.gif" alt="4" style="zoom:50%;" />                                <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.38hljol6hle0.webp" alt="image" style="zoom:95%;" /></p><h5 id="1-1-4-随机"><a href="#1-1-4-随机" class="headerlink" title="1.1.4 随机"></a>1.1.4 随机</h5><p>​         通过上面的一些方法，我们可以生成一些规则的图形，如齿轮，花瓣等等；规则代表着一种美，数学之美，而无序则代表着自由，有无限的想象空间，比如天上的云朵，跳动的火苗，海平面溅起的浪花等，这些自然之物无法用数学公式来把它们限制在一个方程式之下。那只能用魔法去打败魔法了，是随机去模拟大自然的随机，noise就是这门艺术。</p><blockquote><p><a href="https://nashpan.github.io/2021/09/04/shader-noise/#more">shader noise</a></p></blockquote><h4 id="1-3-image"><a href="#1-3-image" class="headerlink" title="1.3 image"></a>1.3 image</h4><h5 id="1-3-1-贴图"><a href="#1-3-1-贴图" class="headerlink" title="1.3.1 贴图"></a>1.3.1 贴图</h5><p>这个比较简单，就是将现有的图片 导入到 我们的画布中，使用函数texture2D即可</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入你的图片，下面的路径是我的文件路径</span></span><br><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/46.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对你的纹理进行采样，获取对应像素处的颜色</span></span><br><span class="line">    <span class="type">vec4</span> color = <span class="built_in">texture2D</span>(iChannel0, uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到屏幕，即为原图</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.31u4tqtqfya0.webp" alt="image">   <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/2e339c48-1d52-4342-a954-8a983f4ac731.png" alt="1" style="zoom:37%;" /></p><p>​                     原图                                                             运行代码图</p><h5 id="1-3-2-玩转图片"><a href="#1-3-2-玩转图片" class="headerlink" title="1.3.2 玩转图片"></a>1.3.2 玩转图片</h5><ul><li><strong>图片转场</strong></li></ul><p>说到图片，大家最先想到的特效是啥？我首先想到的是各种转场</p><blockquote><p><a href="https://gl-transitions.com/gallery">https://gl-transitions.com/gallery</a></p></blockquote><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/1.png&#x27;</span></span><br><span class="line"><span class="meta">#iChannel1 &#x27;file://pictures/46.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> SQRT_2 = <span class="number">1.414213562373</span>;</span><br><span class="line"><span class="type">float</span> dots = <span class="number">20.0</span>;</span><br><span class="line"><span class="type">vec2</span> center = <span class="type">vec2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> transition(<span class="type">vec2</span> uv) &#123;</span><br><span class="line">  <span class="type">bool</span> nextImage = <span class="built_in">distance</span>(<span class="built_in">fract</span>(uv * dots), <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>)) &lt; ( <span class="built_in">fract</span>(iTime * <span class="number">0.4</span>) / <span class="built_in">distance</span>(uv, center));</span><br><span class="line">  <span class="keyword">return</span> nextImage ? <span class="built_in">texture2D</span>(iChannel0, uv) : <span class="built_in">texture2D</span>(iChannel1, uv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / iResolution.xy;</span><br><span class="line">    <span class="type">vec4</span> color = <span class="type">vec4</span>(<span class="number">0.0</span>);</span><br><span class="line">    color = transition(uv);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/5.79leqhys3280.gif" alt="5" style="zoom: 33%;" /><ul><li><strong>制作精灵动画</strong></li></ul><p>​          这一部分是为了说明，对于一幅图片，我们可以只选择其中一部分进行采样；(ps: 文字渲染的一种方式是将所有文字信息离屏渲染到一张纹理上，使用时去查找对应的部分进行渲染）</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/1.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> col = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> row = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / iResolution.xy;</span><br><span class="line">    <span class="type">vec4</span> color = <span class="type">vec4</span>(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> fRes = iResolution.xy / <span class="type">vec2</span>(<span class="type">float</span>(col), <span class="type">float</span>(row));</span><br><span class="line">    <span class="type">vec2</span> nRes = iResolution.xy / fRes;</span><br><span class="line">    uv = uv / nRes;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> timeX = iTime * <span class="number">1.5</span>;</span><br><span class="line">    <span class="type">float</span> timeY = <span class="built_in">floor</span>(timeX / <span class="type">float</span>(col));</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span> (<span class="built_in">floor</span>(timeX) / nRes.x, <span class="number">1.</span> - (<span class="built_in">floor</span>(timeY) / nRes.y));</span><br><span class="line"></span><br><span class="line">    uv = <span class="built_in">fract</span>(uv + <span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line">    color = <span class="built_in">texture2D</span>(iChannel0, uv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = color;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进阶：第三个是抖音上比较火的网格分割图片，配合音乐的卡点</span></span><br><span class="line">    <span class="comment">//      来显示图片，从而产生比较有趣的效果</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//     我们可以基于此的思想 来将我们的众多图片按照不同时间</span></span><br><span class="line">    <span class="comment">//  绘制到画布上形成动画！！！</span></span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.1mbgs1elp11c.webp" alt="image" style="zoom:80%;" />               <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/6.1q8gsml6aexs.gif" alt="6" style="zoom: 30%;" />                   <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/7.1bqb88wkd89s.gif" alt="7" style="zoom: 67%;" /></p><p>​                     原图                                                         运行代码图                                                抖音特效</p><h5 id="1-3-3-图片操作"><a href="#1-3-3-图片操作" class="headerlink" title="1.3.3 图片操作"></a>1.3.3 图片操作</h5><ul><li><strong>反转图片</strong></li></ul><p>​          下面这个图片看起来好像有点阴间的感觉，反转操作可用于通道中颜色较小的值反转成较大的值，然后用于处理，或者相反，是一种数据处理的思想（类似于将数据重新映射，类比于笛卡尔坐标到极坐标，或者从极坐标映射到笛卡尔坐标系），常用的颜色处理还有颜色空间的转换，如RGB颜色空间转换到HSV颜色空间，都是利用了这种思想</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入你的图片，下面的路径是我的文件路径</span></span><br><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/46.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里，这里我只取rgb通道的颜色，因为a通道不用反转</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="built_in">texture2D</span>(iChannel0, uv).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行反转的操作</span></span><br><span class="line">    color = <span class="number">1.0</span> - color;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.5tx13g88hs40.webp" alt="image">                               <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.1oqer3erzu74.webp" alt="image" style="zoom:95%;" /></p><p>​               原图                                                                                     效果图</p><ul><li><strong>图片灰度化</strong></li></ul><p>​        记住这个数字 035911， 即0.3， 0.59， 0.11 (大概是这个比例，有的是0.299, 0.587, 0.114 或者其它，都是按照这个基准进行灰度化的，PS软件的灰度图就是按照这个比例进行灰度化的）</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入你的图片，下面的路径是我的文件路径</span></span><br><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/46.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里，这里我只取rgb通道的颜色，因为a通道不用反转</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="built_in">texture2D</span>(iChannel0, uv).rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行灰度的处理</span></span><br><span class="line">    <span class="type">float</span> grey = color.r * <span class="number">0.3</span> + color.g * <span class="number">0.59</span> + color.b * <span class="number">0.11</span>;</span><br><span class="line">    color = <span class="type">vec3</span>(grey);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.7dsnegk2zr80.webp" alt="image">                              <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.2rd7bnt6ut8.webp" alt="image"></p><p>​                      原图                                                                               效果图</p><ul><li>颜色的加减乘除</li></ul><p>​          这一块对应于AE 或者PS中的 叠加方式，有Add, Substract, Multiply, Average, Difference等等，因为这一块没有发现比较好玩的效果，暂时不深入，一般常用的就是Add方式就可，即colorA + colorB的方式。</p><h5 id="1-3-4-卷积，算子"><a href="#1-3-4-卷积，算子" class="headerlink" title="1.3.4 卷积，算子"></a>1.3.4 卷积，算子</h5><ul><li><p>模糊操作</p><p>主要用到的是**高斯模糊，**其它的还有均值模糊，径向模糊等等，各有各的用途，按照需求选择合适即可。</p></li></ul><blockquote><p><a href="https://zhuanlan.zhihu.com/p/125744132">高品质后处理：十种图像模糊算法的总结与实现</a></p></blockquote><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.3sghfjkaxgo0.webp" alt="image"></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.7ghxkhwd4q80.webp" alt="image"></p><ul><li>边缘检测</li></ul><p>​          边缘的表现形式如下图：<strong>通常是通过寻找图像的梯度来检测边界</strong>，有两种代表算法，sobel算子（基于一阶导数的）和laplacian算子（基于二阶导数）。</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.3nrpt49koba0.webp" alt="image"></p><ol><li><strong>sobel 算子</strong></li></ol><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.2j86nqc9x020.webp" alt="image"></p><p>对于不连续的函数，一阶导数可以写作：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.694l71jtb4k0.webp" alt="image"></p><p> 或</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.2nfbs2zop7m0.webp" alt="image"></p><p>所以有：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.6wq57o3xzs.webp" alt="image"></p><p> 假设要处理的图像为I，在两个方向求导：</p><p> 水平变化：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.gvqie82f40o.webp" alt="image"></p><p>垂直变化：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.7ce4yv3c1800.webp" alt="image"></p><p> 结合以上两个结果求出：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.2aaekdlimp1c.webp" alt="image"></p><p> 统计极大值所在的位置，就是图像的边缘。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#iChannel0 &#x27;file://pictures/pixel.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord.xy / iResolution.xy;</span><br><span class="line">    <span class="type">vec3</span> col;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** Sobel kernels ***/</span></span><br><span class="line">    <span class="comment">// Note: GLSL&#x27;s mat3 is COLUMN-major -&gt;  mat3[col][row]</span></span><br><span class="line">    <span class="type">mat3</span> sobelX = <span class="type">mat3</span>(<span class="number">-1.0</span>, <span class="number">-2.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                       <span class="number">0.0</span>,  <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                       <span class="number">1.0</span>,  <span class="number">2.0</span>,  <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">mat3</span> sobelY = <span class="type">mat3</span>(<span class="number">-1.0</span>,  <span class="number">0.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">                       <span class="number">-2.0</span>,  <span class="number">0.0</span>, <span class="number">2.0</span>,</span><br><span class="line">                       <span class="number">-1.0</span>,  <span class="number">0.0</span>,  <span class="number">1.0</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> sumX = <span class="number">0.0</span>;   <span class="comment">// x-axis change</span></span><br><span class="line">    <span class="type">float</span> sumY = <span class="number">0.0</span>;   <span class="comment">// y-axis change</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// texture coordinates should be between 0.0 and 1.0</span></span><br><span class="line">            <span class="type">float</span> x = (fragCoord.x + <span class="type">float</span>(i))/iResolution.x;   </span><br><span class="line">            <span class="type">float</span> y =  (fragCoord.y + <span class="type">float</span>(j))/iResolution.y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Convolve kernels with image</span></span><br><span class="line">            sumX += <span class="built_in">length</span>(<span class="built_in">texture</span>( iChannel0, <span class="type">vec2</span>(x, y) ).xyz) * <span class="type">float</span>(sobelX[<span class="number">1</span>+i][<span class="number">1</span>+j]);</span><br><span class="line">            sumY += <span class="built_in">length</span>(<span class="built_in">texture</span>( iChannel0, <span class="type">vec2</span>(x, y) ).xyz) * <span class="type">float</span>(sobelY[<span class="number">1</span>+i][<span class="number">1</span>+j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> g = <span class="built_in">abs</span>(sumX) + <span class="built_in">abs</span>(sumY);</span><br><span class="line">    <span class="comment">//g = sqrt((sumX*sumX) + (sumY*sumY));</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(g &gt; <span class="number">1.0</span>)</span><br><span class="line">        col = <span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        col = col * <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    fragColor.xyz = col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.6ttyltgldm80.webp" alt="image"></p><p>​                                                   原图                                                                                  运行算法图</p><p>2.<strong>laplacian算子</strong></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.3dytl7kab920.webp" alt="image"></p><p>对于不连续函数的二阶导数是：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.3g446js1c5u0.webp" alt="image"></p><p>因此使用的卷积核是：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.4gytix99njs0.webp" alt="image"></p><h3 id="2-Shader-和-AI"><a href="#2-Shader-和-AI" class="headerlink" title="2. Shader 和 AI"></a>2. Shader 和 AI</h3><h4 id="2-1-特效相关"><a href="#2-1-特效相关" class="headerlink" title="2.1 特效相关"></a>2.1 特效相关</h4><ul><li>瘦脸特效，大眼特效，头部晃动特效等等</li></ul><p>​        <strong>这里会使用AI的方法提取人物的关键点</strong>，如下图中的左右太阳穴的关键点，下巴的关键点，人体头部的关键点等等，然后再加上图像处理的方法，就会产生很多有趣的效果！！！</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.704q25ekllc0.webp" alt="image" style="zoom: 50%;" />        <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/8.373haivhp600.gif" alt="8" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/9.6oga687i1xc0.gif" alt="9" style="zoom: 50%;" />       <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/10.2g0l6csob89w.gif" alt="10" style="zoom: 58%;" /></p><ul><li>背景特效</li></ul><p>​         这里就会用到AI中的人像分割技术，将人物抠出来，然后背景部分将其灰度化，人物部分保留原始的颜色即可。</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/11.pzbqp854000.gif" alt="11"></p><h4 id="2-2-DLSS"><a href="#2-2-DLSS" class="headerlink" title="2.2 DLSS"></a>2.2 DLSS</h4><blockquote><p>​<a href="https://zhuanlan.zhihu.com/p/116211994">DLSS 2.0 - 重新定义AI渲染</a></p></blockquote><p>​          DLSS简单来说就是我们使用传统的图形学方法渲染一帧低清晰度的图片，然后使用AI的方法将其“复原”成高分辨率的图片，即图片的高清修复。因为在真实感方面，光线追踪技术渲染的真实感很好，但是在高分辨率下，计算量爆炸；有了DLSS后，我们可以使用光线追踪技术渲染低分辨率的图片，然后使用AI进行高清修复。</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/image-hosing/image.4j53kcu7cew0.webp" alt="image" style="zoom:80%;" /><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/426092206">浅谈生成艺术</a></li><li><a href="https://thebookofshaders.com/">the book of shaders</a></li><li><a href="https://www.shadertoy.com/">shadertoy</a></li><li><a href="https://iquilezles.org/">iq大神博客</a></li><li><a href="https://www.shadertoy.com/view/Ms2SD1">https://www.shadertoy.com/view/Ms2SD1</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AR的前世今生</title>
      <link href="/2022/09/27/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2022/09/27/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念区分"><a href="#1-概念区分" class="headerlink" title="1.概念区分"></a>1.概念区分</h2><p><strong>什么是AR&#x2F;VR&#x2F;MR&#x2F;XR?</strong>  在前段时间，元宇宙大火的时候，你应该听过或者见过上面的几个词语。什么？元宇宙都没有听过，建议食用下面的资料了解一下,也是蛮有意思的东西。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/TzuS9-z9WNCszoqFAj2-1g">聊聊这个本不存在的“元宇宙”</a></p></blockquote><p> 啥？全是文字，没事，那就看个视频吧，你也可以简单了解一下这篇文章的主题AR是个什么东西！</p><blockquote><p><a href="https://www.bilibili.com/video/BV1RA41157hM/?spm_id_from=333.337.search-card.all.click&vd_source=d46df11a3bf332ea68a6f3b7af79095d">2021年了，AR眼镜可以做什么？</a></p></blockquote><ul><li>AR</li></ul><p>对现实的一种增强，设备对现实识别（形状、位置、动作、边缘）,从而将虚拟信息叠加在现实中。</p><ul><li>VR</li></ul><p>为用户提供一个虚拟的世界，不必考虑现实世界，是一种沉浸式的体验。如果喜欢看动漫的，**动漫《刀剑神域》<strong>里描述就是这样一个世界(PS: 我感觉这就是当前阶段元宇宙的最终形态)；在</strong>电影《头号玩家》**中，里面塑造的绿洲也是这样的一个虚拟世界。</p><ul><li>MR</li></ul><p>虚拟世界和现实世界的混合。</p><p>  AR、VR、MR统称XR。VR的发展相较于AR的发展，更为成熟一些，有很多VR面对用户的产品，例如Pico 4，这段时间发布了它的新产品。在这里，我们主要聊一聊AR相关的内容。</p><h2 id="2-AR历史发展及现状"><a href="#2-AR历史发展及现状" class="headerlink" title="2.AR历史发展及现状"></a>2.AR历史发展及现状</h2><p>1992年波音公司研究员提出了AR这个概念，自此AR诞生了。</p><h3 id="2-1-AR序幕的开启"><a href="#2-1-AR序幕的开启" class="headerlink" title="2.1 AR序幕的开启"></a>2.1 AR序幕的开启</h3><p>把时间拉回10年前的2012年，在一个慈善晚宴上，谷歌联合创始人谢尔盖·布林为了展示一把谷歌的技术实力，就把尚在原型阶段的谷歌智能眼镜Google Glass掏了出来，众人直呼“卧槽”，随后便引起了大众的广泛讨论和关注。正当大家做着钢铁侠梦的时候，也遇到了视频中小何同学遇到的各种使用问题；虽然Google Glasss更多意义上只是一个“戴在脸上的手机”，很多AR领域涉及的技术，受限于当时的技术和算力，诸如环境检测，用户交互技术等并不涉及，但是其展现的前景还是值得大家期待的。因此，可以说，Google Glass拉起了AR快速发展的序幕。</p><h3 id="2-2-AR的持续发展"><a href="#2-2-AR的持续发展" class="headerlink" title="2.2 AR的持续发展"></a>2.2 AR的持续发展</h3><ul><li><strong>AR界的第一代黑科技</strong></li></ul><p>自从谷歌将Google Glass引入大众的视野，旁边的微软可坐不住了，论技术，咱可没输过谁，就算打不过，那不是最后还可以加入嘛。况且，你的那个Google Glass也太垃圾了吧，这么重，还这么贵，也就是你是第一人，否则不会有那么多人买账，让我来教教你怎么制作一个好的产品吧，是时候展现真正的技术了。于是，在2015年的时候，微软发布了Hololens，震惊了世界，它能检测外界环境，将虚拟物体和显示环境融合，并且它通过追踪用户手势来完成交互。HoloLens2 是真正意义上的第一款相对成熟的AR设备，它的出现，引领了AR的潮流，成为了业界的标杆和对比的对象。</p><p>2019年，微软发布了HoloLens2，解决了视野狭小的问题，并且大幅度提升了手势追踪的准确性。虽然HoloLens2 虽然相对成熟，但是成本居高不下，**官方指导建议零售价是3500美元。**另外，虽然它相对体积较小，但仍重达500g, 已知iPhone 12重152g, 请问你的头上戴了几台iPhone 12 🤣</p><p><img src="/pan_img/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image_1.png" alt="img"></p><ul><li><strong>AR界的第一代黑”概念”</strong></li></ul><p>凭借着下面这“一条在体育馆地板跃起的大鲸鱼”，<strong>Magic Leap</strong> 成功塑造了一个 AR 黑科技公司的形象，以及足够激动人心的未来——从移动计算迁移到空间计算。裸眼AR的概念太具有震撼力，致使Magic Leap在视频发布的短短三个月内，迅速获得16亿美元融资，最高估值达64亿美元。然而巧妇难为无米之炊，在关键技术上没有取得核心突破的Magic Leap在2017年推出的Magic Leap one，其表现与其吹牛的效果差得太离谱，消费者纷纷给出了差评，这也给这家公司贴上了“骗子”的标签。</p><p><img src="/pan_img/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image_2.png" alt="img"></p><p>在上面的视频被人戳破，是视频后期合成之后，这家公司在AR界没有惊起任何浪花，就在写这篇文稿的当天，我在其官网上发现，Magic Leap将发布Magic Leap 2，这回他能否力挽狂澜，拯救自己“骗子”的形象，还得看过硬的产品！</p><p><img src="/pan_img/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image_3.png" alt="img"></p><ul><li>国内AR的发展</li></ul><p>国内的AR公司主要有酷派的Xview系列、亮亮视野、影目科技等，要说目前最火的，当属Nreal，</p><p>在今年的8月23日，Nreal推出了新品Nreal Air和Nreal X两款AR眼镜；发布首日，Nreal销售额突破了1200万。</p><p><img src="/pan_img/AR的前世今生/image_4.png" alt="img" style="zoom: 67%;" />    <img src="/pan_img/AR的前世今生/image_5.png" alt="img" style="zoom:67%;" /></p><p>在9月21日，国内最早成立的AR企业之一亮亮视野发布了一款量产的AR字幕眼镜，也是全球第一款重量小于80g的双目波导无线一体机AR眼镜：听语者。主打听障者沟通。</p><p><img src="/pan_img/AR%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image_6.png" alt="img"></p><p>国内的AR产业也在快速发展中，苹果老早就说2022年要发布AR眼镜，从年头等到了年尾，毛都没有；或许，我们可以把目光转向国内，期待国内的厂商能够发布一款改变世界的产品，就像当时iphone的出现一样。</p><h3 id="2-3-移动端AR比较流行的SDK"><a href="#2-3-移动端AR比较流行的SDK" class="headerlink" title="2.3 移动端AR比较流行的SDK"></a>2.3 移动端AR比较流行的SDK</h3><p>目前移动端AR SDK有很多，下面列出一些比较有影响力的SDK</p><ul><li><strong>苹果的ARKit</strong> ： 2017年发布至今，被认为是性能最强，最具商业潜力的sdk。</li><li><strong>谷歌的ARCore</strong> ： 同时支持Android 和iOS, 是Android比较常用的sdk，综合实力比不上ARKit</li><li>历史悠久的 ARToolKit： 第一个AR SDK，但是目前开源社区不是太活跃</li><li>商业化sdk Vuforia： 性能表现很不错，支持Android、iOS</li></ul><h3 id="2-4-发展现状"><a href="#2-4-发展现状" class="headerlink" title="2.4 发展现状"></a>2.4 发展现状</h3><p>目前AR技术还有很多痛点，主要集中在以下几个方面：</p><ul><li>检测环境的计算量很大，实时性不好，例如当你拿着设备快速移动时，虚拟物体和现实物体的融合就会出现飘移的现象</li><li>因为计算量大和频繁使用摄像头，耗电发热；</li><li>穿戴式AR 显示技术不成熟，大部分设备在清晰度、视野、体验性上都有些不足</li><li>软件生态不成熟</li></ul><h2 id="3-AR领域的关键技术"><a href="#3-AR领域的关键技术" class="headerlink" title="3.AR领域的关键技术"></a>3.AR领域的关键技术</h2><h3 id="3-1-探知环境的技术（自我定位、检测3D物体、环境建模）"><a href="#3-1-探知环境的技术（自我定位、检测3D物体、环境建模）" class="headerlink" title="3.1 探知环境的技术（自我定位、检测3D物体、环境建模）"></a>3.1 探知环境的技术（自我定位、检测3D物体、环境建模）</h3><p> 没错，听到这些词语，很自然想到了自动驾驶里面也会有这样一个环节，就是”理解“环境的技术。</p><p>一般来说，建立环境地图需要经历以下的流程：</p><ol><li>用户抵达一个新场所，开启摄像头。</li><li>设备根据陀螺仪等传感器确定自己的高度、朝向，并以此为空间坐标系原点。</li><li>识别用户摄像头输入，进行“点阵云”建模。</li><li>用户到处移动，直至整个地图被扫描建模完成。</li></ol><h3 id="3-2-显示技术"><a href="#3-2-显示技术" class="headerlink" title="3.2 显示技术"></a>3.2 显示技术</h3><p>AR的另一个关键技术就是显示技术，主要分为三类：</p><ol><li>视觉差显示技术</li><li>全息投影技术</li><li>光影成像技术</li></ol><h3 id="3-3-交互技术"><a href="#3-3-交互技术" class="headerlink" title="3.3 交互技术"></a>3.3 交互技术</h3><p>目前为止，除了传统的触摸，按键、语音等技术，AR大致有3个方向的虚拟交互技术：</p><ul><li>动作捕捉： 主要是手部动捕捉，目前Hololens2在这一块上技术积累最雄厚，不需要任何外设，直接通过手势就可以流畅操控设备。</li><li>眼动追踪： 使用摄像头捕捉人眼或脸部的图像，然后用算法实现人脸和人眼的检测、定位与跟踪，从而估算用户的视线变化。</li><li>脑机接口： 通过识别大脑活动电信号来操控设备，马斯克旗下的Neuralink公司通过向大脑植入十分之一发丝粗细的神经线，来检测和传输大脑的信号。</li></ul><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>​        20年前，当人们使用QICQ打着字，和天南海北的陌生人分享彼此的故事时，不会想到，今天我们一张图片，一个个表情包，一段视频，便可以轻松地将我们的故事分享给陌生人。20年前，我们省吃俭用抠抠搜搜计算着我们的2G流量，发个消息还老转圈圈，到今天，4G已悄然开启了全民直播时代，而5G也已在全面布局。</p><p>​          或许像电影《头号玩家》里面的元宇宙场景还需要很长一段路要走，但至少我觉得AR、VR技术将会在不久的将来带给我们全新的体验，就让我们且走，且看，且体验吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 元宇宙 </tag>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据对齐问题</title>
      <link href="/2021/11/17/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数据对齐问题"><a href="#数据对齐问题" class="headerlink" title="数据对齐问题"></a>数据对齐问题</h2><span id="more"></span><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>我在使用OpenGL加载一个图片数据时,其中数据的宽高不是2的n次方，导致了解析的出来的图片出现了问题，如下图：</p> <img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/opengl_image_error.png" alt="opengl_image_error" style="zoom: 50%;" /><p>我加载纹理数据的代码如下：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/opengl_image_error1.png" alt="opengl_image_error1"></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>像数据在内存中很少以紧密包装的形式存在，在很多硬件平台上，出于性能考虑，图像的每一行应该都从某个特定对齐地址开始。在默认情况下，OpenGL采用4个字节的对齐方式。例如，有一张RGB图像，包含3个分量，每个分量占1个字节，如果图像宽度为199像素，那么每一行需要的字节数为597字节。但是如果硬件的体系结构是以4字节排列，那么图像的每一行末尾都会填充额外的3个空字节，从而使得每一行的内存地址偏移量为4的整数倍。尽管这样表面上看起来是浪费了内存空间，但是这种排列能够让大多数CPU更高效的获取数据块。另外许多未经压缩的图形格式也遵循这种惯例，如Windows中的.BMP文件。Targa(.TGA)是以1字节排列的。</p><p>在向OpenGL提交图像数据或从OpenGL中获取图像数据时，OpenGL需要知道对数据以何种方式包装和解包装操作。通过函数<code>void glPixelStorei (GLenum pname, GLint param)</code>，<code>glPixelStoref (GLenum pname, GLfloat param)</code>可以改变或者恢复像素的存储方式。例如需要改成紧密包装方式(即像素行的对齐方式，可选1.2.4.8)调用函数<code>glPixelStorei(GL_UNPACK_ALIGNMENT, 1)</code>。其参数都是以GL_UNPACK_和GL_PACK_为前缀方式成对出现，前着表示从内存中读取数据(对函数<code>glReadPixels</code>产生影响)，后者表示存储数据至内存中(对调用函数<code>glTexImage2D</code>等产生影响)。</p><p><a href="https://www.jianshu.com/p/513afcb71c97">OpenGL 数据处理(下)</a></p></blockquote><p>解决这个问题的方法是在创建纹理的时候将纹理设置为1字节对齐即可，如下，即可解决问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glPixelStorei</span>(GL_UNPACK_ALIGNMENT, <span class="number">1</span>)     <span class="comment">// 这里的GL_UNPACK_ALIGNMENT是指上传数据</span></span><br></pre></td></tr></table></figure><p>当我们要从fbo读取数据的时候，可能也存在这样的问题，同理，我们在读取纹理的时候设置下面的参数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glPixelStorei</span>(GL_PACK_ALIGNMENT, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理贴图预乘问题</title>
      <link href="/2021/11/17/%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE%E7%9A%84%E9%A2%84%E4%B9%98%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/17/%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE%E7%9A%84%E9%A2%84%E4%B9%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="纹理贴图预乘问题"><a href="#纹理贴图预乘问题" class="headerlink" title="纹理贴图预乘问题"></a>纹理贴图预乘问题</h2><span id="more"></span><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>在一次opengl<strong>纹理贴图贴PNG图片</strong>的过程中，我遇到了下面的问题，结果如下图：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.1g4g07fkd2rk.png" alt="image"> </p><p>​可以发现，贴图的边界存在一些白色的点，非常影响最后的效果。一开始，我以为是没有开mimmap的原因，因为我发现我使用的贴图的精度很高(2560 * 2560),但是并不是，我已经开启mimmap，仍然有白点的存在。我想了很久，一直以为是锯齿或者其它原因，各种RenderDoc，matlab实验，仍没有解决问题，后面在矿哥的帮助下，一秒解决了问题，真大神呀。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h3><p>出现上面的问题不是锯齿的问题，而是alpha blend的问题，上面那张wolf图像的精度是2560 * 2560，进行贴图时会进行缩放，这时会产生一些问题，具体的文章解释见下面的文章解释</p><blockquote><p><a href="https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre">Alpha Blending: To Pre or Not To Pre</a></p><p>[<a href="https://www.cnblogs.com/xiaonanxia/p/9448444.html">图片Alpha预乘的作用</a>]</p></blockquote><p>具体的处理代码</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/alpha_premultiple.png" alt="alpha_premultiple" style="zoom: 80%;" /> <p>预乘之后问题就解决了，结果如下：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.sfg8evv0xvk.png" alt="image"> </p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花屏问题(精度不够导致)</title>
      <link href="/2021/11/17/%E8%8A%B1%E5%B1%8F%E9%97%AE%E9%A2%98(%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%A4%9F%E5%AF%BC%E8%87%B4)/"/>
      <url>/2021/11/17/%E8%8A%B1%E5%B1%8F%E9%97%AE%E9%A2%98(%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%A4%9F%E5%AF%BC%E8%87%B4)/</url>
      
        <content type="html"><![CDATA[<h2 id="花屏问题"><a href="#花屏问题" class="headerlink" title="花屏问题"></a>花屏问题</h2><span id="more"></span><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/video.4jgiqew57kw0.gif" alt="video" style="zoom: 50%;" />  <p>我在使用stbi_image去将一个图片数据转化为纹理图片，我的代码如下：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/stb_image.png" alt="stb_image"></p><p>这里我一开始写的是char,结果输出图片的数据全是0，因为使用char,发生了数据的上溢，变成了0；</p><p>至于上面的那个花屏现象，是由于精度不够导致的。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>刚开始时，我写的是255(下图标记处），结果就出现了花屏的现象</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.2zp4ulu4fmq0.png" alt="image"></p><p>改成255.0之后显示就正常了</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/1.72v379gjerg0.gif" alt="1" style="zoom:50%;" /> ]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RenderDoc使用</title>
      <link href="/2021/11/17/RenderDoc%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/11/17/RenderDoc%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RenderDoc使用"><a href="#RenderDoc使用" class="headerlink" title="RenderDoc使用"></a>RenderDoc使用</h2><span id="more"></span><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>使用RenderDoc调试程序时，程序中涉及到的一些相对路径，可能读取不到，导致无法正常运行程序，因此需要改成绝对路径，如下：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.4uaqe7a5o420.png" alt="image"></p><p>包括读取图片时，那些路径也要设置为绝对路径</p><h3 id="RenderDoc设置环境变量"><a href="#RenderDoc设置环境变量" class="headerlink" title="RenderDoc设置环境变量"></a>RenderDoc设置环境变量</h3><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/renderDoc_problem.png" alt="renderDoc_problem" style="zoom:67%;" /><p>有些程序可能会需要命令行的参数才能执行，并且可能会依赖一些动态库，如图，按照上图进行设置即可</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RenderDoc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色格式问题</title>
      <link href="/2021/11/17/%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/17/%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="颜色格式问题"><a href="#颜色格式问题" class="headerlink" title="颜色格式问题"></a>颜色格式问题</h2><span id="more"></span><p>这个问题可能相对比较简单，但是这里需要注意的重点是，当发生颜色问题时，可以在这一方面想一想，会不会是颜色的顺序不对导致的，是RGBA，还是BRGA，亦或是YUV420等等，这些都会导致最后渲染出来的颜色不对，就像我之前在Metal中的遇到的颜色问题，可能就是这个原因导致的(见下面链接)</p><blockquote><p><a href="https://nashpan.github.io/2021/09/04/%E8%BE%93%E5%87%BA%E7%BA%B9%E7%90%86%E4%B8%BAYUV%E5%92%8CRGB/#more">输出纹理为YUV和RGB</a></p></blockquote><p>下面这张图片是截取于OpenGL的纹理采取那部分的代码，注意图片的格式为jpg，然后读取图片的格式为RGB</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/color.png" alt="color"></p><p>但是下面这张截图中，我需要加载的图片数据的格式是png，是4通道的（调试时可以从nrChannels参数看出），所以正确的方法如下：</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/color1.png" alt="color1" style="zoom:67%;" /> <p>如果格式没有注意的话，就会出现读取的数据不正确的情况</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导入dll问题</title>
      <link href="/2021/11/17/%E5%AF%BC%E5%85%A5dll%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/17/%E5%AF%BC%E5%85%A5dll%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="导入dll问题"><a href="#导入dll问题" class="headerlink" title="导入dll问题"></a>导入dll问题</h2><span id="more"></span><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我在AE中导入dll时，导入失败，但是我确实加载了所有的dll库</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>问题出在我加载的dll也有依赖关系，所以需要按照顺序来加载dll库如下</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.3aavo2gruf20.png" alt="image"></p><p>导入ffmpeg的dll时，在AE中一定要按照上面的顺序进行导入，因为后面的库会依赖前面的库，我之前在这里卡了很久，我当时想着逐个导入，然而我选择的第一个是avformat,这个库会依赖avutil，avcodec，因此代码运行到这儿的时候就会崩掉。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>1.在解决dll相关问题时，可以使用depends软件查看库依赖，很好用</p><p>2.可以使用vs的一些命令行工具查看dll的架构，64 or 32</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metal渲染到纹理</title>
      <link href="/2021/09/04/Metal%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86/"/>
      <url>/2021/09/04/Metal%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h2><span id="more"></span><p>滤镜链</p><blockquote><p><a href="http://81.71.66.22/Metal-5-filter-chain/">Metal - 5 滤镜链（渲染到纹理）</a></p></blockquote><p>Metal的标准坐标系NDC、帧缓存坐标系FrameBuffer Coordinate (也叫Viewport Coorninate)以及纹理坐标系（Texture Coordinate)的原点不一致，还会分别对他们进行介绍和解析。</p><p>在Metal中要渲染到纹理有如下步骤：</p><h3 id="1-创建空纹理"><a href="#1-创建空纹理" class="headerlink" title="1.创建空纹理"></a>1.创建空纹理</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">MTLTexture</span>&gt;)createEmptyTexture: (<span class="type">id</span>&lt;<span class="built_in">MTLDevice</span>&gt;)device</span><br><span class="line">                                    WithWidth: (size_t)width</span><br><span class="line">                                   withHeight: (size_t)height</span><br><span class="line">                                        usage: (<span class="built_in">MTLTextureUsage</span>)usage &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MTLTextureDescriptor</span> *texDescriptor = [<span class="built_in">MTLTextureDescriptor</span> texture2DDescriptorWithPixelFormat: <span class="built_in">MTLPixelFormatRGBA8Unorm</span> width: width height: height mipmapped: <span class="literal">false</span>];</span><br><span class="line">    texDescriptor.usage = usage;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">MTLTexture</span>&gt; texture = [device newTextureWithDescriptor: texDescriptor];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>usage 纹理的用处，是 <code>MTLTextureUsage</code> 枚举，有如下枚举值：<ul><li><code>MTLTextureUsageUnknown</code> 未知用处（运行时设置），会损耗性能</li><li><code>MTLTextureUsageShaderRead</code> 该纹理将被读取</li><li><code>MTLTextureUsageShaderWrite</code> 该纹理将被写入</li><li><code>MTLTextureUsageRenderTarget</code> 该纹理将作为渲染目标</li><li><code>MTLTextureUsagePixelFormatView</code> 在 PixelFormatView 被使用（暂不介绍）</li></ul></li></ul><p>回到 demo 中，这个中间 buffer 是 <strong>当次渲染的渲染目标</strong> ，也将 <strong>作为下一次渲染的输入被读取（采样）</strong>，因此 usage 是 <code>MTLTextureUsageShaderRead | MTLTextureUsageRenderTarget</code>。</p><p>完整调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_grayResultTexutre = [MetalUtils createEmptyTexture: _device</span><br><span class="line">                                              WithWidth: <span class="built_in">CGImageGetWidth</span>(cgImage)</span><br><span class="line">                                             withHeight: <span class="built_in">CGImageGetHeight</span>(cgImage)</span><br><span class="line">                                                  usage: <span class="built_in">MTLTextureUsageShaderRead</span> | <span class="built_in">MTLTextureUsageRenderTarget</span>];</span><br></pre></td></tr></table></figure><h3 id="2-空纹理关联到渲染目标"><a href="#2-空纹理关联到渲染目标" class="headerlink" title="2.空纹理关联到渲染目标"></a>2.空纹理关联到渲染目标</h3><p>以往为了要将渲染结果展示，我们的渲染目标是与 Layer 关联起来的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RenderTargetDesc.colorAttachments[<span class="number">0</span>].texture = currentDrawable.texture;</span><br></pre></td></tr></table></figure><p>但是这次我们需要渲染到纹理上，因此要把 <strong>渲染目标和要渲染到的纹理</strong> 关联起来：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_grayRenderTargetDesc.colorAttachments[<span class="number">0</span>].texture = _grayResultTexutre;</span><br></pre></td></tr></table></figure><h3 id="3-提交指令，执行渲染"><a href="#3-提交指令，执行渲染" class="headerlink" title="3.提交指令，执行渲染"></a>3.提交指令，执行渲染</h3><p>指令是被 ”装“ 到 Encoder 上的，因此渲染过程也大同小异，但是由于 <strong>不需要展示渲染结果（即不需要上屏 swap buffer）</strong>，所以不需要 <code>presentDrawable</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)render_gray &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将本次 Command Encoder 和 渲染的目标（MTLTexture）关联起来</span></span><br><span class="line">    _grayRenderTargetDesc.colorAttachments[<span class="number">0</span>].texture = _grayResultTexutre;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">MTLCommandBuffer</span>&gt; commandBuffer = [_queue commandBuffer];</span><br><span class="line">    commandBuffer.label = <span class="string">@&quot;Gray Command Buffer&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">MTLRenderCommandEncoder</span>&gt; encoder = [commandBuffer renderCommandEncoderWithDescriptor: _grayRenderTargetDesc];</span><br><span class="line">    encoder.label = <span class="string">@&quot;Gray Command Encoder&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    [encoder setViewport: (<span class="built_in">MTLViewport</span>) &#123;</span><br><span class="line">        .originX = <span class="number">0</span>,</span><br><span class="line">        .originY = <span class="number">0</span>,</span><br><span class="line">        .width = _sourceTexutre.width,</span><br><span class="line">        .height = _sourceTexutre.height,</span><br><span class="line">        .znear = <span class="number">0</span>,</span><br><span class="line">        .zfar = <span class="number">1</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [encoder setRenderPipelineState: _grayRenderPipelineState];</span><br><span class="line">    </span><br><span class="line">    [encoder setVertexBytes: grayVertices</span><br><span class="line">                     length: <span class="keyword">sizeof</span>(grayVertices)</span><br><span class="line">                    atIndex: <span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [encoder setVertexBytes: texCoor</span><br><span class="line">                     length: <span class="keyword">sizeof</span>(texCoor)</span><br><span class="line">                    atIndex: <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    [encoder setFragmentTexture: _sourceTexutre</span><br><span class="line">                        atIndex: <span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [encoder setFragmentBytes: &amp;_grayIntensity</span><br><span class="line">                       length: <span class="keyword">sizeof</span>(<span class="type">float</span>)</span><br><span class="line">                      atIndex: <span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [encoder drawIndexedPrimitives: <span class="built_in">MTLPrimitiveTypeTriangleStrip</span></span><br><span class="line">                        indexCount: <span class="number">6</span></span><br><span class="line">                         indexType: <span class="built_in">MTLIndexTypeUInt32</span></span><br><span class="line">                       indexBuffer: _indexBuffer</span><br><span class="line">                 indexBufferOffset: <span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    [encoder endEncoding];</span><br><span class="line">    </span><br><span class="line">    [commandBuffer commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Command Buffer 并不需要 <code>presentDrawable:</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metal中加载MTLLibrary</title>
      <link href="/2021/09/04/Metal%E4%B8%AD%E5%8A%A0%E8%BD%BDMTLLibrary/"/>
      <url>/2021/09/04/Metal%E4%B8%AD%E5%8A%A0%E8%BD%BDMTLLibrary/</url>
      
        <content type="html"><![CDATA[<h2 id="Metal-中加载MTLLibrary"><a href="#Metal-中加载MTLLibrary" class="headerlink" title="Metal 中加载MTLLibrary"></a>Metal 中加载MTLLibrary</h2><span id="more"></span><p>一般情形下，我们加载MTLLibrary会使用如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span>&lt;<span class="built_in">MTLLibrary</span>&gt; defaultLibrary = [<span class="keyword">self</span>.mtkView.device newDefaultLibrary]</span><br></pre></td></tr></table></figure><p>确实这样是正确的，没有问题的，但是如果我们是开发一个静态库，.Metal 文件放置在你的静态库工程文件中，在测试时使用上面的函数就会找不到这个Metal文件，当然，你把Metal文件复制到你的开发工程中，可以正常运行，但是这样的话，Metal文件就暴露出来了，而且我们给其他人提供静态库时，不可能顺带还把Metal文件给他，因此需要换一种方法加载Metal文件</p><p>在苹果的官方论坛上，提供了一种方法<a href="https://developer.apple.com/forums/thread/52287">一种方法</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSString</span> *libPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;MySecretMetalLib&quot;</span> ofType:<span class="string">@&quot;metallib&quot;</span>];</span><br><span class="line"><span class="type">id</span>&lt;<span class="built_in">MTLLibrary</span>&gt; library = [device newLibraryWithFile:libPath error:&amp;error];</span><br></pre></td></tr></table></figure><p>当然，如果我们查看device创建library的方法文档的话，也会找到下面的方法，即将metal文件转化成字符串，然后传入，类似于OpenGL中传入shader文件。方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span>&lt;<span class="built_in">MTLLibrary</span>&gt; defaultLibrary = [m_metalRendererDevice newLibraryWithSource:shaderSource options: <span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>对应的shaderSource文件为：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/image.16nns81u3bts.png" alt="image"> </p><p>当然我们也可以手动添加双引号将Metal文件转化为字符串，但是个人觉得太麻烦了，然后就学习了别人的这种字符串化写法，当然如果是C++的话，可以直接使用R();当然，开始的时候还遇到了其它问题，注意到上面图中的红色部分，一开始，我没有添加，后面添加了就可以正常读取Metal文件中后面的函数了。</p><p>另外，字符串化里面好像不能添加如下的引用（不太确定，但是我的metal文件确实没有编译成功，可能和metal文件的编译方式有关系，先记录在这儿吧，后面解决坑了再回来填坑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ShaderTypes.h&quot;</span>   <span class="comment">//直接将结构体写进字符串里面就行，</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS新手村 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输出纹理为YUV和RGB</title>
      <link href="/2021/09/04/%E8%BE%93%E5%87%BA%E7%BA%B9%E7%90%86%E4%B8%BAYUV%E5%92%8CRGB/"/>
      <url>/2021/09/04/%E8%BE%93%E5%87%BA%E7%BA%B9%E7%90%86%E4%B8%BAYUV%E5%92%8CRGB/</url>
      
        <content type="html"><![CDATA[<h2 id="输出纹理为YUV-和RGB"><a href="#输出纹理为YUV-和RGB" class="headerlink" title="输出纹理为YUV 和RGB"></a>输出纹理为YUV 和RGB</h2><span id="more"></span><p>写这篇博客，是因为我在使用OpenGL ES渲染从视频获取的纹理时(使用YUV的方式)，出现了颜色偏差的问题，但是我仔细看了我的代码，采样坐标，参数设置等都没有问题，然后我也学习了别人的相关代码，发现使用的方式都是一样的，因此被这个问题卡主了，于是只好换一种方式了，因此借鉴了下面这篇文章的设置方法，将视频输出数据直接设置为RGB，解决了颜色偏差的问题</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1141269">AVPlayer初体验之视频解纹理</a></p></blockquote><h3 id="1-YUV纹理"><a href="#1-YUV纹理" class="headerlink" title="1.YUV纹理"></a>1.YUV纹理</h3><p>由于视频的编码格式基本都是YUV420，然后苹果的<a href="https://developer.apple.com/library/archive/samplecode/AVBasicVideoOutput/Listings/AVBasicVideoOutput_APLEAGLView_m.html#//apple_ref/doc/uid/DTS40013109-AVBasicVideoOutput_APLEAGLView_m-DontLinkElementID_6">demo代码</a>中通过AVPlayerItemVideoOutput获取Y-Pannel和 UV-Pannel 两张纹理，最后在Shader中对两种纹理组合处理。</p><p>设置<code>AVPlayerItemVideoOutput</code>的部分代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixBuffAttributes = @&#123;(<span class="type">id</span>)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange)&#125;;</span><br><span class="line"><span class="keyword">self</span>.videoOutput = [[<span class="built_in">AVPlayerItemVideoOutput</span> alloc] initWithPixelBufferAttributes:pixBuffAttributes];</span><br></pre></td></tr></table></figure><p>输出纹理的部分代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Y-Plane</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, <span class="literal">NULL</span>, GL_TEXTURE_2D, GL_RED_EXT, frameWidth, frameHeight, GL_RED_EXT, GL_UNSIGNED_BYTE, <span class="number">0</span>, &amp;_lumaTexture);</span><br><span class="line"><span class="comment">//UV-plane</span></span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, <span class="literal">NULL</span>, GL_TEXTURE_2D, GL_RG_EXT, frameWidth / <span class="number">2</span>, frameHeight / <span class="number">2</span>, GL_RG_EXT, GL_UNSIGNED_BYTE, <span class="number">1</span>, &amp;_chromaTexture);</span><br></pre></td></tr></table></figure><p>其中的<code>kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange</code>是CoreVideo中指定的<a href="https://developer.apple.com/documentation/corevideo/1563591-pixel_format_identifiers?language=objc">Pixel Format Identifiers</a> 类型，在<code>OpenGLES2</code>环境下其对应的参数是<code>GL_RED_EXT</code>和<code>GL_RG_EXT</code>。</p><h3 id="2-RGB纹理"><a href="#2-RGB纹理" class="headerlink" title="2.RGB纹理"></a>2.RGB纹理</h3><p>首先要明白一点，上图中明确说明，<code>BGRA</code>的输出格式是<code>420v</code>的两倍多带宽(<em>More than 2x bandwidth</em>)，并且在该图来源,WWDC的<a href="https://developer.apple.com/videos/play/wwdc2011/419/">这个视频</a>的<code>27:00</code>位置明确说明420v的输出格式效率会明显高于BGRA的输出格式(<em>It does come across if you can avoid using BGRA and doing your work in YUV, it’s more efficient from bandwidth standpoint</em>),但是反过来，对于OpenGL来说，两张纹理的性能又会低于一张纹理。而且直接使用使用<code>BGRA</code>毕竟会方便很多，因为输出的直接就是一张纹理。但是现在毕竟都iOS11时代了，所以影响可以忽略不计。</p><p>设置<code>AVPlayerItemVideoOutput</code>的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixBuffAttributes = @&#123;(<span class="type">id</span>)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)&#125;;</span><br><span class="line"><span class="keyword">self</span>.videoOutput = [[<span class="built_in">AVPlayerItemVideoOutput</span> alloc] initWithPixelBufferAttributes:pixBuffAttributes];</span><br></pre></td></tr></table></figure><p>输出纹理的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVReturn textureRet = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, <span class="keyword">self</span>.videoTextureCache, pixelBuffer, <span class="literal">nil</span>, GL_TEXTURE_2D, GL_RGBA, width, height, GL_BGRA, GL_UNSIGNED_BYTE, <span class="number">0</span>, &amp;_textureOutput);</span><br></pre></td></tr></table></figure><p><code>BGRA</code>对应的输出格式是<code>kCVPixelFormatType_32BGRA</code>,其对应的从Buffer读纹理的参数是<code>GL_RGBA</code>和<code>GL_BGRA</code>。</p><blockquote><p>2021.9.3</p><p>后面想了一下，我是输出到一个CALayer上的，CALayer上也有默认的颜色显示方式，应该是这一项不匹配导致的，因为当时的bug是颜色偏蓝，偏红(我试着改变了输出的RGB值时出现的现象)，可能是这个原因，因为当时没有考虑到这一点，后面如果遇到类似问题，试着查一下显示Layer的显示方式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader noise</title>
      <link href="/2021/09/04/shader-noise/"/>
      <url>/2021/09/04/shader-noise/</url>
      
        <content type="html"><![CDATA[<h2 id="Noise噪声"><a href="#Noise噪声" class="headerlink" title="Noise噪声"></a>Noise噪声</h2><span id="more"></span><h3 id="什么是噪声"><a href="#什么是噪声" class="headerlink" title="什么是噪声"></a>什么是噪声</h3><p><strong>噪声 &#x3D; 随机 + 连续</strong></p><p>在图形学中，我们使用噪声就是为了把一些随机变量来引入到程序中。从程序角度来说，噪声很好理解，我们希望给定一个输入，程序可以给出一个输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">value_type <span class="title">noise</span><span class="params">(value_type p)</span> </span>&#123;   <span class="comment">//简单理解为程序语言中的random即可</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的输入和输出类型的维数可以是不同的组合，例如输入二维输出一维，输入二维输出二维等。我们今天就是想讨论一下上面函数中的实现部分是长什么样的。</p><h3 id="噪声的分类"><a href="#噪声的分类" class="headerlink" title="噪声的分类"></a>噪声的分类</h3><p>根据wiki，由程序产生噪声的方法大致可以分为两类：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_category.png" alt="noise_category"></p><p>Perlin噪声、Simplex噪声和Value噪声在性能上大致满足：Perlin噪声(O(2^n)) &lt; Value噪声&lt; Simplex噪声(O(n^2))，Simplex噪声性能最好,效果也最好。</p><h3 id="Perlin-Noise"><a href="#Perlin-Noise" class="headerlink" title="Perlin Noise"></a>Perlin Noise</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>概括来说，Perlin噪声的实现需要三个步骤：</p><ol><li><p>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</p></li><li><p>输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2的n次方个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2的n次方个点乘结果。</p></li><li><p>使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)&#x3D;3t^2−2t^3，在2002年的论文6中，Perlin改进为s(t)&#x3D;6t^5−15t^4+10t^3，这里简单解释一下，为什么不直接使用s(t)&#x3D;t，即线性插值。直接使用的线性插值的话，它的一阶导在晶格顶点处（即t &#x3D; 0或t &#x3D; 1）不为0，会造成明显的不连续性。s(t)&#x3D;3t^2−2t^3，在一阶导满足连续性，s(t)&#x3D;6t^5−15t^4+10t^3，在二阶导上仍然满足连续性。<br>我们可以用下面的图来表示上面的第一步和第二步：</p></li></ol><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/perlin_noise.png" alt="perlin_noise"></p><h4 id="Perlin噪声的实现"><a href="#Perlin噪声的实现" class="headerlink" title="Perlin噪声的实现"></a>Perlin噪声的实现</h4><p>主要代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">hash22</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="built_in">vec2</span>( <span class="built_in">dot</span>(p,<span class="built_in">vec2</span>(<span class="number">127.1</span>,<span class="number">311.7</span>)),</span><br><span class="line">              <span class="built_in">dot</span>(p,<span class="built_in">vec2</span>(<span class="number">269.5</span>,<span class="number">183.3</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span> + <span class="number">2.0</span> * <span class="built_in">fract</span>(<span class="built_in">sin</span>(p)*<span class="number">43758.5453123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">perlin_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 pi = <span class="built_in">floor</span>(p);</span><br><span class="line">    vec2 pf = p - pi;</span><br><span class="line"></span><br><span class="line">    vec2 w = pf * pf * (<span class="number">3.0</span> - <span class="number">2.0</span> * pf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(<span class="built_in">mix</span>(<span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), </span><br><span class="line">                   <span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), w.x), </span><br><span class="line">               <span class="built_in">mix</span>(<span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), </span><br><span class="line">                   <span class="built_in">dot</span>(<span class="built_in">hash22</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), pf - <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), w.x),</span><br><span class="line">               w.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现实际是简化版的，我们在算梯度的时候直接取随机值，而没有归一化到单位圆内。</p><h3 id="Value-Noise"><a href="#Value-Noise" class="headerlink" title="Value Noise"></a>Value Noise</h3><p>它把原来的梯度替换成了一个简单的伪随机值，我们也<strong>不需要进行点乘操作</strong>，而直接把晶格顶点处的随机值按权重相加即可。如下图，即只需要将蓝色矩形中四个顶点的随机值按权重相加。</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/value_noise1.png" alt="value_noise1" style="zoom:67%;" /> <h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>和Perlin噪声一样，它也是一种基于晶格的噪声，也需要三个步骤：</p><ol><li><p>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的值（Value）。对于二维的Value噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</p></li><li><p>输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2 个），得到这些顶点的伪随机值。</p></li><li><p>使用缓和曲线（ease curves）来计算它们的权重和。同样，缓和曲线可以是s(t) &#x3D; 3t^2 - 2t^2,也可以是s(t)&#x3D;6t^5−15t^4+10t^3（如果二阶导不连续对效果影响较大时）。</p></li></ol><p>Value噪声比Perlin噪声的实现更加简单，并且需要的乘法和加法操作也更少，它只需要得到晶格顶点的随机值再把它们按权重相加即可。</p><h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">value_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 pi = <span class="built_in">floor</span>(p);</span><br><span class="line">    vec2 pf = p - pi;</span><br><span class="line"></span><br><span class="line">    vec2 w = pf * pf * (<span class="number">3.0</span> - <span class="number">2.0</span> * pf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(<span class="built_in">mix</span>(<span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)), <span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>)), w.x),</span><br><span class="line">               <span class="built_in">mix</span>(<span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>)), <span class="built_in">hash21</span>(pi + <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)), w.x),</span><br><span class="line">               w.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Simplex-Noise"><a href="#Simplex-Noise" class="headerlink" title="Simplex Noise"></a>Simplex Noise</h3><p>Simplex噪声的计算复杂度为O(n^2^)，优于Perlin噪声的O(2n)。而且在效果上，Simplex噪声也克服了经典的Perlin噪声在某些视觉问题。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/simplex_noise.png" alt="simplex_noise" style="zoom:65%;" /><p>和perlin实现的区别是将上面的矩形换成了一个三角形，所以现在存在一个问题：如何找到上面图形的三个顶点，解决方案如下图：</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/simplex_noise1.png" alt="simplex_noise1"></p><p>将等边三角形倾斜即可转化为矩形，找到顶点后，再做逆向操作即可。</p><h4 id="主要代码-1"><a href="#主要代码-1" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">simplex_noise</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> K1 = <span class="number">0.366025404</span>; <span class="comment">// (sqrt(3)-1)/2;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> K2 = <span class="number">0.211324865</span>; <span class="comment">// (3-sqrt(3))/6;</span></span><br><span class="line"></span><br><span class="line">    vec2 i = <span class="built_in">floor</span>(p + (p.x + p.y) * K1);</span><br><span class="line"></span><br><span class="line">    vec2 a = p - (i - (i.x + i.y) * K2);</span><br><span class="line">    vec2 o = (a.x &lt; a.y) ? <span class="built_in">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>) : <span class="built_in">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    vec2 b = a - o + K2;</span><br><span class="line">    vec2 c = a - <span class="number">1.0</span> + <span class="number">2.0</span> * K2;</span><br><span class="line"></span><br><span class="line">    vec3 h = <span class="built_in">max</span>(<span class="number">0.5</span> - <span class="built_in">vec3</span>(<span class="built_in">dot</span>(a, a), <span class="built_in">dot</span>(b, b), <span class="built_in">dot</span>(c, c)), <span class="number">0.0</span>);</span><br><span class="line">    vec3 n = h * h * h * h * <span class="built_in">vec3</span>(<span class="built_in">dot</span>(a, <span class="built_in">hash22</span>(i)), <span class="built_in">dot</span>(b, <span class="built_in">hash22</span>(i + o)), <span class="built_in">dot</span>(c, <span class="built_in">hash22</span>(i + <span class="number">1.0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(<span class="built_in">vec3</span>(<span class="number">70.0</span>, <span class="number">70.0</span>, <span class="number">70.0</span>), n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wavelet-Noise"><a href="#Wavelet-Noise" class="headerlink" title="Wavelet Noise"></a>Wavelet Noise</h3><p>当使用一个3D噪声去绘制2D纹理表面时，容易出现走样和细节丢失的情形</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/waveletNoise.png" alt="waveletNoise" style="zoom: 67%;" /> <p>Wavelet Noise正是为了解决这个问题</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/wavelet_noise_generation.png" alt="wavelet_noise_generation" style="zoom:50%;" />         <p>主要经过了4个步骤：</p><ol><li>产生一个噪声图R</li><li>降采样</li><li>上采样</li><li>将原图减去上采样的纹理图得到结果图</li></ol><h3 id="Worley-Noise"><a href="#Worley-Noise" class="headerlink" title="Worley Noise"></a>Worley Noise</h3><p>Worley噪声属于一种细胞噪声，就是噪声值是由随机的特征点向外扩散，最终看起来像是有一个个晶胞一样的效果。也叫网格噪声，<strong>是基于距离场</strong></p><p>这种细胞噪声可以应用于模拟皮革，水面等等。（Worley噪声是Voronoi噪声的改进版）</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>把空间分割成网格（cells），每个网格对应一个特征点。另外，为避免网格交界区域的偏差，我们需要计算像素点到相邻网格中的特征点的距离。这就是 <a href="http://www.rhythmiccanvas.com/research/papers/worley.pdf">Steven Worley 的论文</a>中的主要思想。最后，每个像素点只需要计算到九个特征点的距离：他所在的网格的特征点和相邻的八个网格的特征点。</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/worley_noise_principle.png" alt="worley_noise_principle" style="zoom: 67%;" /> <h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> r(<span class="type">vec2</span> n)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="type">vec2</span>(r(n.x*<span class="number">23.62</span><span class="number">-300.0</span>+n.y*<span class="number">34.35</span>),r(n.x*<span class="number">45.13</span>+<span class="number">256.0</span>+n.y*<span class="number">38.89</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Worley2D(<span class="type">vec2</span> n,<span class="type">float</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    n /= s;</span><br><span class="line">    <span class="type">float</span> dis = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>;x&lt;=<span class="number">1</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>;y&lt;=<span class="number">1</span>;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">vec2</span> p = <span class="built_in">floor</span>(n)+<span class="type">vec2</span>(x,y);</span><br><span class="line">            p = r(p)+<span class="type">vec2</span>(x,y)-<span class="built_in">fract</span>(n);</span><br><span class="line">            dis = <span class="built_in">min</span>(dis, <span class="built_in">dot</span>(p, p));        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - <span class="built_in">sqrt</span>(dis);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> WorleyFBM(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> amplitude = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> gain = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> lacunarity = <span class="number">2.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> value = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="type">int</span> STEPS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; STEPS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">     value += Worley2D(uv, <span class="number">2.0</span>) * amplitude;</span><br><span class="line">        amplitude *= gain;</span><br><span class="line">        uv *= lacunarity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FBM"><a href="#FBM" class="headerlink" title="FBM"></a>FBM</h3><p>单独一个Perlin噪声虽然也有一定用处，但是效果往往很无趣。因此，Perlin指出可以使用不同的函数组合来得到更有意思的结果，这些函数组合通常就是指通过分形叠加（fractal sum）。</p><ul><li><strong>fbm 分形噪声</strong></li></ul><p>noise的叠加公式如下：<br>$$<br>noise(p) + 1&#x2F;2 noise(2P) + 1&#x2F;4 noise(4p) + …<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fbm 叠加分形噪声</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">4.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">noise</span>(p); p = <span class="number">2.0</span> * p;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面叠加了5层，并把初始化采样距离设置为4，这都是可以自定义的。这种噪声可以用来模拟石头、山脉这类物体。</p><ul><li><strong>对噪声返回值进行了取绝对值操作。它使用的公式如下</strong>：</li></ul><p>$$<br>|noise(p)| + 1&#x2F;2|noise(2p)| + 1&#x2F;4|noise(4p)|+….<br>$$</p><p>它对应的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum_abs</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">7.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于进行了绝对值操作，因此会在0值变化处出现不连续性，形成一些尖锐的效果。通过合适的颜色叠加，**我们可以用这种噪声来模拟火焰、云朵这些物体。**Perlin把这个公式称为turbulence（湍流？），因为它看起来挺像的。</p><ul><li><strong>在之前turbulnece公式的基础上使用了一个关于表面x分量的正选函数：</strong></li></ul><p>$$<br>sin(x+|noise(p) + 1&#x2F;2|noise(2p)+ 1&#x2F;4|noise(4p)|+…)<br>$$</p><p>这个公式可以让表面沿着x方向形成一个条纹状的结构。Perlin使用这个公式模拟了一些大理石材质。我们的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">noise_sum_abs_sin</span><span class="params">(vec2 p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    p = p * <span class="number">7.0</span>;</span><br><span class="line">    f += <span class="number">1.0000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.5000</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.2500</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.1250</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f += <span class="number">0.0625</span> * <span class="built_in">abs</span>(<span class="built_in">noise</span>(p)); p = <span class="number">2.0</span> * p;</span><br><span class="line">    f = <span class="built_in">sin</span>(f + p.x/<span class="number">32.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多层叠加，每层noise添加位移和旋转"><a href="#多层叠加，每层noise添加位移和旋转" class="headerlink" title="多层叠加，每层noise添加位移和旋转"></a>多层叠加，每层noise添加位移和旋转</h4><blockquote><p><a href="https://blog.csdn.net/tjw02241035621611/article/details/80048713">中级Shader教程07 熔岩Lava</a></p></blockquote><p>通过FBM构造基本形态，在FBM添加点变化：1.每一层的移动速度不一样  2.每层的旋转不一样</p><p>相关代码</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fbm ( <span class="keyword">in</span> <span class="type">vec2</span> _st) &#123;</span><br><span class="line">    <span class="type">float</span> v = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> shift = <span class="type">vec2</span>(<span class="number">100.0</span>);</span><br><span class="line">    <span class="comment">// Rotate to reduce axial bias</span></span><br><span class="line">    <span class="type">mat2</span> rot = <span class="type">mat2</span>(<span class="built_in">cos</span>(<span class="number">0.5</span>), <span class="built_in">sin</span>(<span class="number">0.5</span>),</span><br><span class="line">                    -<span class="built_in">sin</span>(<span class="number">0.5</span>), <span class="built_in">cos</span>(<span class="number">0.50</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_OCTAVES; ++i) &#123;</span><br><span class="line">        v += a * noise(_st);</span><br><span class="line">        _st = rot * _st * <span class="number">2.0</span> + shift;    <span class="comment">//***********************************注意这里乘以了一个矩阵，并且加上了一个偏移量</span></span><br><span class="line">        a *= <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="域翘曲"><a href="#域翘曲" class="headerlink" title="域翘曲"></a>域翘曲</h4><blockquote><p>[<a href="https://www.iquilezles.org/www/articles/warp/warp.htm">domain warping - 2002</a>]</p></blockquote><p><em>f(p) &#x3D; fbm( p + fbm( p + fbm( p ) ) )</em></p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/warp_fbm.png" alt="warp_fbm"> </p><h3 id="可平埔的噪声"><a href="#可平埔的噪声" class="headerlink" title="可平埔的噪声"></a>可平埔的噪声</h3><p>目前公认比较好的一种做法，就是在2n维上生成n维可平铺的噪声。</p><blockquote><p>这种方法是思想是，由于我们想要每个维度都是无缝的，也就是当该维度的值从0变成1的过程中，0和1之间比较是平滑过渡的，这让我们想起了“圆”，绕圆一周就是对该维度的采样过程，这样就可以保证无缝了。因此，对于二维噪声中的x轴，我们会在四维空间下的xz平面上的一个圆上进行采样，而二维噪声的y轴，则会在四维空间下的yw平面上的一个圆上进行采样。这个转化过程很简单，我们只需要使用三角函数sin和cos即可把二维采样坐标转化到单位圆上。同样，三维空间的也是类似的，我们会在六维空间下计算。这种方法不仅适用于Perlin噪声，像Worley噪声这种也同样是适合的。</p><p><a href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></p></blockquote><h3 id="Curl-Noise"><a href="#Curl-Noise" class="headerlink" title="Curl Noise"></a>Curl Noise</h3><blockquote><p><a href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a></p></blockquote><h3 id="noise-的应用"><a href="#noise-的应用" class="headerlink" title="noise 的应用"></a>noise 的应用</h3><blockquote><p><a href="http://devmag.org.za/2009/04/25/perlin-noise/"><strong>How to Use Perlin Noise in Your Games</strong></a></p></blockquote><blockquote><p><strong>Perlin noise can be used to blend between two textures</strong>, as shown in following. You should use Perlin noise with very high contrast to prevent textures from looking fuzzy. The following code snippet shows how to blend two images using Perlin noise.</p></blockquote><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_application.png" alt="noise_application"></p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><blockquote><p><a href="https://zhuanlan.zhihu.com/p/70144964">使用噪音模拟云的效果</a></p><p><a href="https://medium.com/@maksimtianblue/unity-shader-2d%E5%8A%A8%E6%80%81%E4%BA%91%E5%BD%A9-5f26d445a80a">2D动态云彩</a></p></blockquote><p>生成云的shadertoy代码如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudscale = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> speed = <span class="number">0.03</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> clouddark = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudlight = <span class="number">0.3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudcover = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> cloudalpha = <span class="number">8.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> skytint = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">vec3</span> skycolour1 = <span class="type">vec3</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="type">vec3</span> skycolour2 = <span class="type">vec3</span>(<span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">mat2</span> m = <span class="type">mat2</span>( <span class="number">1.6</span>,  <span class="number">1.2</span>, <span class="number">-1.2</span>,  <span class="number">1.6</span> );</span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> hash( <span class="type">vec2</span> p ) &#123;</span><br><span class="line">p = <span class="type">vec2</span>(<span class="built_in">dot</span>(p,<span class="type">vec2</span>(<span class="number">127.1</span>,<span class="number">311.7</span>)), <span class="built_in">dot</span>(p,<span class="type">vec2</span>(<span class="number">269.5</span>,<span class="number">183.3</span>)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1.0</span> + <span class="number">2.0</span>*<span class="built_in">fract</span>(<span class="built_in">sin</span>(p)*<span class="number">43758.5453123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> noise( <span class="keyword">in</span> <span class="type">vec2</span> p ) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> K1 = <span class="number">0.366025404</span>; <span class="comment">// (sqrt(3)-1)/2;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> K2 = <span class="number">0.211324865</span>; <span class="comment">// (3-sqrt(3))/6;</span></span><br><span class="line"><span class="type">vec2</span> i = <span class="built_in">floor</span>(p + (p.x+p.y)*K1);</span><br><span class="line">    <span class="type">vec2</span> a = p - i + (i.x+i.y)*K2;</span><br><span class="line">    <span class="type">vec2</span> o = (a.x&gt;a.y) ? <span class="type">vec2</span>(<span class="number">1.0</span>,<span class="number">0.0</span>) : <span class="type">vec2</span>(<span class="number">0.0</span>,<span class="number">1.0</span>); <span class="comment">//vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));</span></span><br><span class="line">    <span class="type">vec2</span> b = a - o + K2;</span><br><span class="line"><span class="type">vec2</span> c = a - <span class="number">1.0</span> + <span class="number">2.0</span>*K2;</span><br><span class="line">    <span class="type">vec3</span> h = <span class="built_in">max</span>(<span class="number">0.5</span>-<span class="type">vec3</span>(<span class="built_in">dot</span>(a,a), <span class="built_in">dot</span>(b,b), <span class="built_in">dot</span>(c,c) ), <span class="number">0.0</span> );</span><br><span class="line"><span class="type">vec3</span> n = h*h*h*h*<span class="type">vec3</span>( <span class="built_in">dot</span>(a,hash(i+<span class="number">0.0</span>)), <span class="built_in">dot</span>(b,hash(i+o)), <span class="built_in">dot</span>(c,hash(i+<span class="number">1.0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>(n, <span class="type">vec3</span>(<span class="number">70.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fbm(<span class="type">vec2</span> n) &#123;</span><br><span class="line"><span class="type">float</span> total = <span class="number">0.0</span>, amplitude = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">total += noise(n) * amplitude;</span><br><span class="line">n = m * n;</span><br><span class="line">amplitude *= <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord ) &#123;</span><br><span class="line">    <span class="type">vec2</span> p = fragCoord.xy / iResolution.xy;</span><br><span class="line"><span class="type">vec2</span> uv = p*<span class="type">vec2</span>(iResolution.x/iResolution.y,<span class="number">1.0</span>);    </span><br><span class="line">    <span class="type">float</span> time = iTime * speed;</span><br><span class="line">    <span class="type">float</span> q = fbm(uv * cloudscale * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ridged noise shape</span></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//noise shape</span></span><br><span class="line"><span class="type">float</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// uv = p*vec2(iResolution.x/iResolution.y,1.0);</span></span><br><span class="line">uv *= cloudscale;</span><br><span class="line">    uv -= q - time;    </span><br><span class="line">    <span class="type">float</span> weight = <span class="number">0.7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">f += weight*noise( uv );    </span><br><span class="line">        uv = m*uv + time;</span><br><span class="line">weight *= <span class="number">0.6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f *= r + f;</span><br><span class="line">  </span><br><span class="line">    <span class="type">vec3</span> skycolour = <span class="built_in">mix</span>(skycolour2, skycolour1, p.y);</span><br><span class="line">    <span class="type">vec3</span> cloudcolour = <span class="type">vec3</span>(<span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">0.9</span>) * clouddark;</span><br><span class="line">    f = cloudcover + cloudalpha*f; </span><br><span class="line">    <span class="type">vec3</span> result = <span class="built_in">mix</span>(skycolour, <span class="built_in">clamp</span>(skytint * skycolour + cloudcolour, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="built_in">clamp</span>(f, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">fragColor = <span class="type">vec4</span>( result, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码的效果如下图：</p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/Cloud.gif" alt="Cloud" style="zoom:50%;" /><h4 id="山脉"><a href="#山脉" class="headerlink" title="山脉"></a>山脉</h4><p>使用噪声作为高度图</p><p><img src="https://raw.githubusercontent.com/nashpan/image-hosting/main/markdown_image/noise_heightMap.png" alt="noise_heightMap"></p><h4 id="水面"><a href="#水面" class="headerlink" title="水面"></a>水面</h4><p>使用噪声纹理作为高度图，不断修改水面的法线方向，使用和时间相关的变量对噪声纹理采样，得到水流动的效果；</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>noise的其它应用如生成细胞形态，皮革纹理，烟雾，大理石，布料，道路等，基本思想都是基于噪声贴图，使用噪声图作为基本纹理进行处理，如color mapping，height mapping, normal mapping等</p><h3 id="noise-的相关库"><a href="#noise-的相关库" class="headerlink" title="noise 的相关库"></a>noise 的相关库</h3><ul><li><a href="http://libnoise.sourceforge.net/index.html">libnoise</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://juejin.cn/post/6844903862298476557">WebGL进阶——走进图形噪声</a></li></ol><p>2.<a href="https://www.shadertoy.com/view/ldscWj">https://www.shadertoy.com/view/ldscWj</a></p><p>3.<a href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></p><ol start="4"><li><a href="https://zhuanlan.zhihu.com/p/50418658">使用笔、和代码”生成“火焰</a></li></ol><p>5.<a href="https://www.cnblogs.com/leoin2012/p/7218033.html">[一篇文章搞懂柏林噪声算法]</a></p><p>6.<a href="https://zhuanlan.zhihu.com/p/341673601">几种常见的程序化噪声纹理</a></p><p>7.<a href="https://blog.csdn.net/linjf520/article/details/100005528">Unity Shader - Noise 噪点图 - 实现简单山脉</a></p><p>8.<a href="https://www.nvidia.fr/docs/IO/8343/RealTime-Procedural-Effects.pdf">Real-Time Procedural Effects</a></p><p>9.<a href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a></p><p>10.<a href="https://time.geekbang.org/column/article/267016?utm_source=related_read&utm_medium=article&utm_term=related_read">如何使用噪声生成复杂的纹理？</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2021/08/22/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/08/22/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://light-city.club/sc/">C++那些事</a></p></blockquote><span id="more"></span><h3 id="const那些事"><a href="#const那些事" class="headerlink" title="const那些事"></a>const那些事</h3><h4 id="const含义"><a href="#const含义" class="headerlink" title="const含义"></a>const含义</h4><p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值是不能被更新的。</p><h4 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h4><p>1.可以定义常量</p><p>2.类型检查</p><p>3.防止修改，起保护作用，增加程序健壮性</p><p>4.可以节省空间，避免不必要的内存分配</p><h4 id="const对象默认为文件局部变量"><a href="#const对象默认为文件局部变量" class="headerlink" title="const对象默认为文件局部变量"></a>const对象默认为文件局部变量</h4><blockquote><p>注意：非const变量默认为extern。要使const变量能够在其它文件中访问，必须在文件中显示地指定它为extern。</p></blockquote><ul><li>未被const修饰的变量在不同文件的访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> ext                                          <span class="comment">//**********************************这里没有extern</span></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * by 光城</span></span><br><span class="line"><span class="comment"> * compile: g++ -o file file2.cpp file1.cpp</span></span><br><span class="line"><span class="comment"> * execute: ./file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;(ext<span class="number">+10</span>)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const常量在不同文件的访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern_file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext=<span class="number">12</span>;                         <span class="comment">//********************************这里加了extern</span></span><br><span class="line"><span class="comment">//extern_file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * by 光城</span></span><br><span class="line"><span class="comment"> * compile: g++ -o file const_file2.cpp const_file1.cpp</span></span><br><span class="line"><span class="comment"> * execute: ./file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;ext&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>小结：可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，<u><em>并且需要做初始化！</em></u>因为常量在定义后就不能被修改，所以定义时必须初始化。</em>*</p><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>与指针相关的const有四种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure><p>小结：如果<em>const</em>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于<code>*</code>的右侧，<em>const</em>就是修饰指针本身，即指针本身是常量。</p><p>1.指向常量的指针</p><p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p><p>将非const对象的地址赋给const对象的指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">ptr = &amp;val; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>小结：对于指向常量的指针，不能通过指针来修改对象的值。<br>也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p><p>2.常指针</p><p>**const指针必须进行初始化，**且const指针的值不能修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//const指针必须初始化！且const指针的值不能修改</span></span><br><span class="line">    <span class="type">int</span> * t = &amp;num;</span><br><span class="line">    *t = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static那些事"><a href="#static那些事" class="headerlink" title="static那些事"></a>static那些事</h3><p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p><p>1.<strong>静态变量</strong>：函数中的变量，类中的变量</p><p>2.<strong>静态类的成员</strong>：类对象和类中的函数</p><p><strong>静态变量</strong></p><ul><li>函数中的静态变量</li></ul><p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)  </span><br><span class="line">        <span class="built_in">demo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><ul><li>类中的静态变量</li></ul><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享。**对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><p>类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Apple</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>;                           <span class="comment">//******************************************在这里进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Apple obj; </span><br><span class="line">    <span class="comment">// prints value of i </span></span><br><span class="line">    cout &lt;&lt; obj.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><ul><li>类对象为静态</li></ul><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><ul><li>类中的静态函数</li></ul><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。***我们被允许使用对象和’.’来调用静态成员函数。***<strong>但建议</strong>使用类名和范围解析运算符调用静态成员。</p><p><strong>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</strong></p><h3 id="this指针那些事"><a href="#this指针那些事" class="headerlink" title="this指针那些事"></a>this指针那些事</h3><h4 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h4><ol><li>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</li><li>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，**即使你没有写上this指针，编译器在编译的时候也是加上this的，**它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</li></ol><h4 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h4><ol><li>在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</li><li>当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span></span>&#123;                         <span class="comment">//*****************************注意这里的const和总结里的解析</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function">Person&amp; <span class="title">add_age</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        age+=a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。上述的get_age函数会被解析成<code>get_age(const A * const this)</code>,<code>add_age</code>函数会被解析成<code>add_age(A* const this,int a)</code>。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了。</p></blockquote><h3 id="inline那些事"><a href="#inline那些事" class="headerlink" title="inline那些事"></a>inline那些事</h3><h4 id="类中内联"><a href="#类中内联" class="headerlink" title="类中内联"></a>类中内联</h4><p>头文件中声明方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！                         //***********************这里</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  //***********************这里  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现文件中定义内联函数：</p><blockquote><p><strong>inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><p>以下情况不适合用内联：</p><ol><li>如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li></ol><h4 id="虚函数-virtual-可以是内联函数吗？"><a href="#虚函数-virtual-可以是内联函数吗？" class="headerlink" title="虚函数(virtual)可以是内联函数吗？"></a>虚函数(virtual)可以是内联函数吗？</h4><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="sizeof-那些事"><a href="#sizeof-那些事" class="headerlink" title="sizeof 那些事"></a>sizeof 那些事</h3><ul><li>空类的大小为1字节</li><li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li><li><strong>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</strong></li><li>普通继承，派生类继承了所有基类的函数与成员，<em><strong><u>要按照字节对齐来计算大小</u></strong></em></li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li><li>虚继承,继承基类的vptr。</li></ul><h4 id="原则1"><a href="#原则1" class="headerlink" title="原则1"></a>原则1</h4><p>空类的大小为1字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file blackclass.cpp</span></span><br><span class="line"><span class="comment"> * @brief 空类的大小为1字节</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原则2"><a href="#原则2" class="headerlink" title="原则2"></a>原则2</h4><p>静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file static.cpp</span></span><br><span class="line"><span class="comment"> * @brief 静态数据成员</span></span><br><span class="line"><span class="comment"> * 静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。 </span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 16  字节对齐、静态变量不影响类的大小、vptr指针=8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原则3"><a href="#原则3" class="headerlink" title="原则3"></a>原则3</h4><p>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file morevir.cpp</span></span><br><span class="line"><span class="comment"> * @brief 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原则4和5"><a href="#原则4和5" class="headerlink" title="原则4和5"></a>原则4和5</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file geninhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)</span></span><br><span class="line"><span class="comment"> * 注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。</span></span><br><span class="line"><span class="comment"> * 2.虚单继承，派生类继承基类vptr</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 此时B按照顺序：</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐4+4=8+8+8=24                        //************************这里存在疑问，我觉得是16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">short</span> a;</span><br><span class="line">        <span class="type">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl; <span class="comment">// 8</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl; <span class="comment">// 24</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl; <span class="comment">// 12</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(C1)&lt;&lt;endl; <span class="comment">// 8 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;C++</span><br></pre></td></tr></table></figure><h4 id="原则6"><a href="#原则6" class="headerlink" title="原则6"></a>原则6</h4><p>虚继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file virnhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 虚继承</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span>  A, <span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 8 8 16  派生类虚继承多个虚函数，会继承所有虚函数的vptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vptr-vtable那些事"><a href="#vptr-vtable那些事" class="headerlink" title="vptr_vtable那些事"></a>vptr_vtable那些事</h3><h4 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h4><p>为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态&#x2F;后期绑定方式的函数调用函数的查找表。</p><p>首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个隐藏指向基类的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。</p><h4 id="实现与内部结构"><a href="#实现与内部结构" class="headerlink" title="实现与内部结构"></a>实现与内部结构</h4><p>下面我们来看自动与手动操纵vptr来获取地址与调用虚函数！</p><p>代码调用图：</p><img src="C:\Users\panren\AppData\Roaming\Typora\typora-user-images\image-20210220171317121.png" alt="image-20210220171317121" style="zoom: 67%;" /> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file vptr1.cpp</span></span><br><span class="line"><span class="comment"> * @brief C++虚函数vptr和vtable</span></span><br><span class="line"><span class="comment"> * 编译：g++ -g -o vptr vptr1.cpp -std=c++11</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">()</span></span>;                                  <span class="comment">//**************************这里不是很理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 派生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived::fun1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DerivedClass::fun2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fun <span class="title">getAddr</span><span class="params">(<span class="type">void</span>* obj,<span class="type">unsigned</span> <span class="type">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">void</span>* vptr_addr = (<span class="type">void</span> *)*(<span class="type">unsigned</span> <span class="type">long</span> *)obj;  <span class="comment">//64位操作系统，占8字节，通过*(unsigned long *)obj取出前8字节，即vptr指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vptr_addr:%p\n&quot;</span>,vptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过vptr指针访问virtual table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned long *)vptr_addr取出前8字节，</span></span><br><span class="line"><span class="comment">     * 后面加上偏移量就是每个函数的地址！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* func_addr = (<span class="type">void</span> *)*((<span class="type">unsigned</span> <span class="type">long</span> *)vptr_addr+offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func_addr:%p\n&quot;</span>,func_addr);</span><br><span class="line">    <span class="keyword">return</span> (Fun)func_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base ptr;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">    Base &amp;pp = ptr; <span class="comment">// 基类引用指向基类实例</span></span><br><span class="line">    Base &amp;p = d; <span class="comment">// 基类引用指向派生类实例</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象直接调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ptr.<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类对象调用基类实例&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pp.<span class="built_in">fun1</span>(); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pt-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;基类引用指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动查找vptr 和 vtable</span></span><br><span class="line">    Fun f1 = <span class="built_in">getAddr</span>(pt, <span class="number">0</span>);</span><br><span class="line">    (*f1)();</span><br><span class="line">    Fun f2 = <span class="built_in">getAddr</span>(pt, <span class="number">1</span>);</span><br><span class="line">    (*f2)();</span><br><span class="line">    <span class="keyword">delete</span> pt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="virtual那些事"><a href="#virtual那些事" class="headerlink" title="virtual那些事"></a>virtual那些事</h3><h4 id="虚函数中默认参数"><a href="#虚函数中默认参数" class="headerlink" title="虚函数中默认参数"></a>虚函数中默认参数</h4><p><strong>默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</strong>。</p><h4 id="可以不可以"><a href="#可以不可以" class="headerlink" title="可以不可以"></a>可以不可以</h4><ul><li>静态函数可以声明为虚函数吗？</li></ul><p><strong>静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰</strong></p><p>static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义</p><p>虚函数依靠vptr和vtable来处理。<em><strong>vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。</strong></em></p><ul><li>构造函数可以为虚函数吗？</li></ul><p>构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。</p><p>为什么构造函数不可以为虚函数？</p><p>不可以也没有必要。</p><p><strong>尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。</strong> 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。</p><p>我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。 因此，构造函数没有必要被声明为虚函数。</p><ul><li>虚函数可以为私有函数吗？</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file virtual_function.cpp</span></span><br><span class="line"><span class="comment"> * @brief 虚函数可以被私有化，但有一些细节需要注意。</span></span><br><span class="line"><span class="comment"> * 基类指针指向继承类对象，则调用继承类对象的函数；</span></span><br><span class="line"><span class="comment"> * int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。 </span></span><br><span class="line"><span class="comment"> * 当然，把基类声明为public， 继承类为private，该问题就不存在了。----&gt; 见另外一个例子！</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base Fun&quot;</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived Fun&quot;</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Derived; </span><br><span class="line">    ptr-&gt;<span class="built_in">fun</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RTTI与dynamic-cast"><a href="#RTTI与dynamic-cast" class="headerlink" title="RTTI与dynamic_cast"></a>RTTI与dynamic_cast</h4><p>RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用***<u>基类的指针或引用</u>***来检查这些指针或引用所指的对象的实际派生类型。</p><p>在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file rtti.cpp</span></span><br><span class="line"><span class="comment"> * @brief 在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CPP program to illustrate  </span></span><br><span class="line"><span class="comment">// // Run Time Type Identification  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    B *b = <span class="keyword">new</span> D;  <span class="comment">// 向上转型</span></span><br><span class="line">    B &amp;obj = *b;</span><br><span class="line">    D *d = <span class="built_in">dynamic_cast</span>&lt;D*&gt;(b);   <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="keyword">if</span>(d != <span class="literal">NULL</span>) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;works&quot;</span>&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cannot cast B* to D*&quot;</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        D&amp; dobj = <span class="built_in">dynamic_cast</span>&lt;D&amp;&gt;(obj);  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;works&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125; <span class="built_in">catch</span> (bad_cast bc) &#123; <span class="comment">// ERROR</span></span><br><span class="line">        cout&lt;&lt;bc.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在使用时需要注意：被转换对象obj的类型T1必须是多态类型，即T1必须公有继承自其它类，或者T1拥有虚函数（继承或自定义）。若T1为非多态类型，使用dynamic_cast会报编译错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A为非多态类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B为多态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//D为多态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E为非多态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> : <span class="keyword">private</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//F为多态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">private</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile-那些事"><a href="#volatile-那些事" class="headerlink" title="volatile 那些事"></a>volatile 那些事</h3><p>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</p><h4 id="volatile使用"><a href="#volatile使用" class="headerlink" title="volatile使用"></a>volatile使用</h4><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用volatile告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p><h4 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a>volatile应用</h4><ol><li>并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>; <span class="comment">//定义一个IO端口；  </span></span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">init</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">    *output = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  init(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    *output = 9;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p><p>2.一个中断服务子程序中访问到的变量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(i) <span class="built_in">dosomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt service routine */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IRS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。</p><p>3.多线程应用中被多个任务共享的变量。</p><p>当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">bool</span> bStop=<span class="literal">false</span>;  <span class="comment">//bStop 为共享全局变量  </span></span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(!bStop)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个线程终止上面的线程循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    bStop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p><p>是否了解volatile的应用场景是区分C&#x2F;C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。</p><h4 id="volatile常见问题"><a href="#volatile常见问题" class="headerlink" title="volatile常见问题"></a>volatile常见问题</h4><p>下面的问题可以看一下面试者是不是直正了解volatile。</p><ol><li>一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</li></ol><blockquote><p>const修饰的变量在程序里面是不能改变的，但是可以被程序外的东西修改，就象上面说的外部端口的值，如果仅仅使用const，有可能complier会优化掉这些变量，加上volatile就万无一失了。</p></blockquote><ol><li>一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。</li><li>下面的函数有什么错误？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> *ptr * *ptr; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="type">int</span> a,b; </span><br><span class="line">a = *ptr; </span><br><span class="line">b = *ptr; </span><br><span class="line"><span class="keyword">return</span> a * b; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="type">int</span> a=*ptr; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="assert那些事"><a href="#assert那些事" class="headerlink" title="assert那些事"></a>assert那些事</h3><h4 id="第一个断言案例"><a href="#第一个断言案例" class="headerlink" title="第一个断言案例"></a>第一个断言案例</h4><p>断言，<em><u><strong>是宏，而非函数</strong></u></em>。assert 宏的原型定义在 （C）、（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="断言与正常错误处理"><a href="#断言与正常错误处理" class="headerlink" title="断言与正常错误处理"></a>断言与正常错误处理</h4><p>断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。</p><p>忽略断言：</p><p>在代码开头加上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br></pre></td></tr></table></figure><h3 id="extern-“C”那些事"><a href="#extern-“C”那些事" class="headerlink" title="extern “C”那些事"></a>extern “C”那些事</h3><h4 id="C-与C编译区别"><a href="#C-与C编译区别" class="headerlink" title="C++与C编译区别"></a>C++与C编译区别</h4><p>在C++中常在头文件见到extern “C”修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。</p><p>C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。</p><p>例如<code>int add(int a, int b)</code>函数经过C++编译器生成.o文件后，<code>add</code>会变成形如<code>add_int_int</code>之类的, 而C的话则会是形如<code>_add</code>, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。</p><p>这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时<code>extern &quot;C&quot;</code>就起作用了：告诉链接器去寻找<code>_add</code>这类的C语言符号，而不是经过C++修饰的符号。</p><h4 id="C-调用C函数"><a href="#C-调用C函数" class="headerlink" title="C++调用C函数"></a>C++调用C函数</h4><p>C++调用C函数的例子: 引用C的头文件时，需要加<code>extern &quot;C&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Generate add.o file</span></span><br><span class="line">gcc -c add.c</span><br></pre></td></tr></table></figure><p>链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ add.cpp add.o -o main</span><br></pre></td></tr></table></figure><p>没有添加extern “C” 报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; g++ add.cpp add.o -o main                                   </span><br><span class="line">add.o：在函数‘main’中：</span><br><span class="line">add.cpp:(.text<span class="number">+0x0</span>): `main<span class="string">&#x27;被多次定义</span></span><br><span class="line"><span class="string">/tmp/ccH65yQF.o:add.cpp:(.text+0x0)：第一次在此定义</span></span><br><span class="line"><span class="string">/tmp/ccH65yQF.o：在函数‘main’中：</span></span><br><span class="line"><span class="string">add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用</span></span><br><span class="line"><span class="string">add.o：在函数‘main’中：</span></span><br><span class="line"><span class="string">add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure><p>添加extern “C”后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候一定要注意，先通过gcc生成中间文件add.o。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c </span><br></pre></td></tr></table></figure><p>然后编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ add.cpp add.o -o main</span><br></pre></td></tr></table></figure><h4 id="C中调用C-函数"><a href="#C中调用C-函数" class="headerlink" title="C中调用C++函数"></a>C中调用C++函数</h4><p><code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;                       <span class="comment">//***********************************放在C++文件中</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;        <span class="comment">//********************************************这里加extern</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p><ul><li>C++调用C函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C调用C++函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="struct那些事"><a href="#struct那些事" class="headerlink" title="struct那些事"></a>struct那些事</h3><h4 id="C和C-中的Struct区别"><a href="#C和C-中的Struct区别" class="headerlink" title="C和C++中的Struct区别"></a>C和C++中的Struct区别</h4><img src="C:\Users\panren\AppData\Roaming\Typora\typora-user-images\image-20210222114612312.png" alt="image-20210222114612312" style="zoom:80%;" /> <h4 id="struct-和class区别"><a href="#struct-和class区别" class="headerlink" title="struct 和class区别"></a>struct 和class区别</h4><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><p>区别:</p><p><strong>最本质的一个区别就是默认的访问控制</strong></p><p>默认的继承访问权限。struct 是 public 的，class 是 private 的。</p><p>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</p><h3 id="UNION那些事"><a href="#UNION那些事" class="headerlink" title="UNION那些事"></a>UNION那些事</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h3 id="C实现C-的面向对象特性"><a href="#C实现C-的面向对象特性" class="headerlink" title="C实现C++的面向对象特性"></a>C实现C++的面向对象特性</h3><h4 id="C-实现案例"><a href="#C-实现案例" class="headerlink" title="C++实现案例"></a>C++实现案例</h4><p>C++中的多态:在C++中会维护一张虚函数表，根据赋值兼容规则，我们知道父类的指针或者引用是可以指向子类对象的。</p><p>如果一个父类的指针或者引用调用父类的虚函数则该父类的指针会在自己的虚函数表中查找自己的函数地址，如果该父类对象的指针或者引用指向的是子类的对象，而且该子类已经重写了父类的虚函数，则该指针会调用子类的已经重写的虚函数。</p><h4 id="C实现"><a href="#C实现" class="headerlink" title="C实现"></a>C实现</h4><ol><li>封装</li></ol><p>C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；</p><p>使用函数指针把属性与方法封装到结构体中。</p><p>2.继承</p><p>结构体嵌套</p><p>3.多态</p><p>类与子类方法的函数指针不同</p><p>在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><p>模拟多态，必须保持函数指针变量对齐(在内容上完全一致，而且变量对齐上也完全一致)。否则父类指针指向子类对象，运行崩溃！</p><h3 id="explicit那些事"><a href="#explicit那些事" class="headerlink" title="explicit那些事"></a>explicit那些事</h3><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line">    A a2 = <span class="number">1</span>;        <span class="comment">// OK：复制初始化</span></span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;        <span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    A a4 = &#123; <span class="number">1</span> &#125;;        <span class="comment">// OK：复制列表初始化</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">    <span class="built_in">doA</span>(<span class="number">1</span>);            <span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (a1);        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">a6</span><span class="params">(a1)</span></span>;        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="type">bool</span> a7 = a1;        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="type">bool</span> a8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line"><span class="comment">//    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">    B b3&#123; <span class="number">1</span> &#125;;        <span class="comment">// OK：直接列表初始化</span></span><br><span class="line"><span class="comment">//    B b4 = &#123; 1 &#125;;        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line"><span class="comment">//    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (b1);        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="comment">//    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">    <span class="type">bool</span> b8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="friend-那些事"><a href="#friend-那些事" class="headerlink" title="friend 那些事"></a>friend 那些事</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：</p><ol><li>友元函数：普通函数对一个访问某个类中的私有或保护成员。</li><li>友元类：类A中的成员函数访问类B中的私有或保护成员</li></ol><p>优点：提高了程序的运行效率。</p><p>缺点：破坏了类的封装性和数据的透明性。</p><p>总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制</p><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>在类声明的任何区域中声明，而定义则在类的外部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;类型&gt;&lt;友元函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure><p>注意，友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _a):<span class="built_in">a</span>(_a)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">geta</span><span class="params">(A &amp;ca)</span></span>;  <span class="comment">///&lt; 友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">(A &amp;ca)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ca.a;                      <span class="comment">//*********************************访问到了私有属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">geta</span>(a)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的声明在该类的声明中，而实现在该类外。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> &lt;友元类名&gt;;</span><br></pre></td></tr></table></figure><p>类B是类A的友元，那么类B可以直接访问A的私有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _a):<span class="built_in">a</span>(_a)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">(A ca)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ca.a; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    B b;</span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">getb</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。</li><li>友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。</li></ul><h3 id="using-那些事"><a href="#using-那些事" class="headerlink" title="using 那些事"></a>using 那些事</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>局部与全局using，具体操作与使用见下面案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isNs1 1</span></span><br><span class="line"><span class="comment">//#define isGlobal 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ns1::func&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> isNs1 </span></span><br><span class="line">    <span class="keyword">using</span> ns1::func;    <span class="comment">/// ns1中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> isGlobal</span></span><br><span class="line">    <span class="keyword">using</span> ::func; <span class="comment">/// 全局中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;other::func&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这就是为什么在c++中使用了cmath而不是math.h头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ns2::<span class="built_in">func</span>(); <span class="comment">// 会根据当前环境定义宏的不同来调用不同命名空间下的func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变访问性"><a href="#改变访问性" class="headerlink" title="改变访问性"></a>改变访问性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n;  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。</p><p>如果对于基类的重载函数，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Base::f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Base::f;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Derived::f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">f</span>();</span><br><span class="line">    d.<span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。</p><h4 id="取代typedef"><a href="#取代typedef" class="headerlink" title="取代typedef"></a>取代typedef</h4><p>C中常用typedef A B这样的语法，将B定义为A类型，也就是给A类型一个别名B</p><p>对应typedef A B，使用using B&#x3D;A可以进行同样的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; V1; </span><br><span class="line"><span class="keyword">using</span> V2 = vector&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="那些事"><a href="#那些事" class="headerlink" title="::那些事"></a>::那些事</h3><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul><h3 id="enum那些事"><a href="#enum那些事" class="headerlink" title="enum那些事"></a>enum那些事</h3><h4 id="传统行为"><a href="#传统行为" class="headerlink" title="传统行为"></a>传统行为</h4><p>枚举有如下问题：</p><ul><li>作用域不受限,会容易引起命名冲突。例如下面无法编译通过的：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;RED,BLUE&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Feeling</span> &#123;EXCITED,BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会隐式转换为int</li><li>用来表征枚举变量的实际类型不能明确指定，从而无法支持枚举类型的前向声明。</li></ul><h4 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h4><p>解决作用域不受限带来的命名冲突问题的一个简单方法是，给枚举变量命名时加前缀，如上面例子改成 COLOR_BLUE 以及 FEELING_BLUE。</p><p>一般说来，为了一致性我们会把所有常量统一加上前缀。但是这样定义枚举变量的代码就显得累赘。C 程序中可能不得不这样做。不过 C++ 程序员恐怕都不喜欢这种方法。替代方案是命名空间:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Color </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">    &#123;</span><br><span class="line">        RED=<span class="number">15</span>,</span><br><span class="line">        YELLOW,</span><br><span class="line">        BLUE</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样之后就可以用 <code>Color::Type c = Color::RED;</code> 来定义新的枚举变量了。如果 <code>using namespace Color</code> 后，前缀还可以省去，使得代码简化。不过，因为命名空间是可以随后被扩充内容的，所以它提供的作用域封闭性不高。在大项目中，还是有可能不同人给不同的东西起同样的枚举类型名。</p><p>更“有效”的办法是用一个类或结构体来限定其作用域，例如：定义新变量的方法和上面命名空间的相同。不过这样就不用担心类在别处被修改内容。这里用结构体而非类，一是因为本身希望这些常量可以公开访问，二是因为它只包含数据没有成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">    &#123;</span><br><span class="line">        RED=<span class="number">102</span>,</span><br><span class="line">        YELLOW,</span><br><span class="line">        BLUE</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-11的枚举类"><a href="#C-11的枚举类" class="headerlink" title="C++11的枚举类"></a>C++11的枚举类</h4><p>上面的做法解决了第一个问题，但对于后两个仍无能为力。庆幸的是，C++11 标准中引入了“枚举类”(enum class)，可以较好地解决上述问题。</p><ul><li>新的enum的作用域不在是全局的</li><li>不能隐式转换成其他类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C++11的枚举类</span></span><br><span class="line"><span class="comment"> * 下面等价于enum class Color2:int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color2</span></span><br><span class="line">&#123;</span><br><span class="line">    RED=<span class="number">2</span>,</span><br><span class="line">    YELLOW,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line">r2 c2 = Color2::RED;</span><br><span class="line">cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c2) &lt;&lt; endl; <span class="comment">//必须转！</span></span><br></pre></td></tr></table></figure><ul><li>可以指定用特定的类型来存储enum</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color3</span>:<span class="type">char</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color3</span>:<span class="type">char</span> </span><br><span class="line">&#123;</span><br><span class="line">    RED=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> c3 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(Color3::RED);</span><br></pre></td></tr></table></figure><h4 id="类中的枚举类型"><a href="#类中的枚举类型" class="headerlink" title="类中的枚举类型"></a>类中的枚举类型</h4><p>有时我们希望某些常量只在类中有效。 由于#define 定义的宏常量是全局的，不能达到目的，于是想到实用const 修饰数据成员来实现。而const 数据成员的确是存在的，但其含义却不是我们所期望的。</p><p>const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。</p><p>不能在类声明中初始化 const 数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道 SIZE 的值是什么。(c++11标准前)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;   <span class="comment">// 错误，企图在类声明中初始化 const 数据成员 </span></span><br><span class="line">  <span class="type">int</span> array[SIZE];  <span class="comment">// 错误，未知的 SIZE </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>正确应该在类的构造函数的初始化列表中进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> size);  <span class="comment">// 构造函数 </span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> SIZE ;    </span><br><span class="line">&#125;; </span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> size) : <span class="built_in">SIZE</span>(size)  <span class="comment">// 构造函数的定义</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function">A  <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 对象 a 的 SIZE 值为 100 </span></span><br><span class="line"><span class="function">A  <span class="title">b</span><span class="params">(<span class="number">200</span>)</span></span>; <span class="comment">// 对象 b 的 SIZE 值为 200 </span></span><br></pre></td></tr></table></figure><p>怎样才能建立在整个类中都恒定的常量呢？</p><p>别指望 const 数据成员了，应该用类中的枚举常量来实现。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        BOY = <span class="number">0</span>,</span><br><span class="line">        GIRL</span><br><span class="line">    &#125;SexType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。</span></span><br></pre></td></tr></table></figure><p>枚举常量不会占用对象的存储空间，它们在编译时被全部求值。</p><p>枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>decltype的语法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (expression)</span><br></pre></td></tr></table></figure><p><strong>这里的括号是必不可少的</strong>,decltype的作用是“查询表达式的类型”，因此，上面语句的效果是，返回 expression 表达式的类型。注意，decltype 仅仅“查询”表达式的类型，并不会对表达式进行“求值”。</p><ul><li>推导出表达式类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a; <span class="comment">//推导结果为int。a的类型为int。</span></span><br></pre></td></tr></table></figure><ul><li>与using&#x2F;typedef合用，用于定义类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">size_t</span> = <span class="keyword">decltype</span>(<span class="built_in">sizeof</span>(<span class="number">0</span>));<span class="comment">//sizeof(a)的返回值为size_t类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">ptrdiff_t</span> = <span class="keyword">decltype</span>((<span class="type">int</span>*)<span class="number">0</span> - (<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="type">nullptr_t</span> = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br><span class="line">vector&lt;<span class="type">int</span> &gt;vec;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>;</span><br><span class="line"><span class="keyword">for</span> (vectype i = vec.begin; i != vec.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样和auto一样，也提高了代码的可读性。</p><ul><li>重用匿名类型</li></ul><p>在C++中，我们有时候会遇上一些匿名类型，如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d ;</span><br><span class="line">    doubel b;</span><br><span class="line">&#125;anon_s;</span><br></pre></td></tr></table></figure><p>而借助decltype，我们可以重新使用这个匿名的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(anon_s) as ;<span class="comment">//定义了一个上面匿名的结构体</span></span><br></pre></td></tr></table></figure><ul><li>泛型编程中结合auto，用于追踪函数的返回值类型</li></ul><p>这也是decltype最大的用途了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T x, T y)</span>-&gt;<span class="title">decltype</span><span class="params">(x*y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判别规则"><a href="#判别规则" class="headerlink" title="判别规则"></a>判别规则</h4><p>对于decltype(e)而言，其判别结果受以下条件的影响：</p><p>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp; 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&amp;。 否则，假设e的类型是T，则decltype（e）为T。</p><h3 id="引用和指针那些事"><a href="#引用和指针那些事" class="headerlink" title="引用和指针那些事"></a>引用和指针那些事</h3><h4 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h4><img src="C:\Users\panren\AppData\Roaming\Typora\typora-user-images\image-20210222172633561.png" alt="image-20210222172633561" style="zoom:80%;" /> <blockquote><p>引用必须初始化，而指针可以不初始化。</p></blockquote><blockquote><p>引用不能为空，而指针可以为空。</p></blockquote><p>由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_p</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != null_ptr)    <span class="comment">//对p所指对象赋值时需先判断p是否为空指针</span></span><br><span class="line">        *p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_r</span><span class="params">(<span class="type">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//由于引用不能为空，所以此处无需判断r的有效性就可以对r直接赋值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>左值引用</li></ul><p>常规引用，一般表示对象的身份。</p><ul><li>右值引用</li></ul><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ol><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ol><h4 id="指针与引用的性能差距"><a href="#指针与引用的性能差距" class="headerlink" title="指针与引用的性能差距"></a>指针与引用的性能差距</h4><p>指针与引用之间有没有性能差距呢？这种问题就需要进入汇编层面去看一下。我们先写一个test1函数，参数传递使用指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">3</span>;    <span class="comment">//此处应该首先判断p是否为空，为了测试的需要，此处我们没加。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码段对应的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">disassemble </span></span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">test1</span><span class="params">(<span class="type">int</span>*)</span>:</span></span><br><span class="line"><span class="function">   <span class="number">0x0000000000400886</span> &lt;<span class="number">+0</span>&gt;:  push   %rbp</span></span><br><span class="line"><span class="function">   <span class="number">0x0000000000400887</span> &lt;<span class="number">+1</span>&gt;:  mov    %rsp,%rbp</span></span><br><span class="line"><span class="function">   <span class="number">0x000000000040088a</span> &lt;<span class="number">+4</span>&gt;:  mov    %rdi,<span class="number">-0x8</span>(%rbp)</span></span><br><span class="line"><span class="function">=</span>&gt; <span class="number">0x000000000040088e</span> &lt;<span class="number">+8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x0000000000400892</span> &lt;<span class="number">+12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)</span><br><span class="line">   <span class="number">0x0000000000400898</span> &lt;<span class="number">+18</span>&gt;: nop</span><br><span class="line">   <span class="number">0x0000000000400899</span> &lt;<span class="number">+19</span>&gt;: pop    %rbp</span><br><span class="line">   <span class="number">0x000000000040089a</span> &lt;<span class="number">+20</span>&gt;: retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>上述代码1、2行是参数调用保存现场操作；第3行是参数传递，函数调用第一个参数一般放在rdi寄存器，此行代码把rdi寄存器值（指针p的值）写入栈中；第4行是把栈中p的值写入rax寄存器；第5行是把立即数3写入到<strong>rax寄存器值所指向的内存</strong>中，此处要注意(%rax)两边的括号，这个括号并并不是可有可无的，(%rax)和%rax完全是两种意义，(%rax)代表rax寄存器中值所代表地址部分的内存，即相当于C++代码中的*p，而%rax代表rax寄存器，相当于C++代码中的p值，所以汇编这里使用了(%rax)而不是%rax。</p><p>我们再写出参数传递使用引用的C++代码段test2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//赋值前无需判断reference是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">disassemble </span></span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">test2</span><span class="params">(<span class="type">int</span>&amp;)</span>:</span></span><br><span class="line"><span class="function">   <span class="number">0x000000000040089b</span> &lt;<span class="number">+0</span>&gt;:  push   %rbp</span></span><br><span class="line"><span class="function">   <span class="number">0x000000000040089c</span> &lt;<span class="number">+1</span>&gt;:  mov    %rsp,%rbp</span></span><br><span class="line"><span class="function">   <span class="number">0x000000000040089f</span> &lt;<span class="number">+4</span>&gt;:  mov    %rdi,<span class="number">-0x8</span>(%rbp)</span></span><br><span class="line"><span class="function">=</span>&gt; <span class="number">0x00000000004008a3</span> &lt;<span class="number">+8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x00000000004008a7</span> &lt;<span class="number">+12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)</span><br><span class="line">   <span class="number">0x00000000004008ad</span> &lt;<span class="number">+18</span>&gt;: nop</span><br><span class="line">   <span class="number">0x00000000004008ae</span> &lt;<span class="number">+19</span>&gt;: pop    %rbp</span><br><span class="line">   <span class="number">0x00000000004008af</span> &lt;<span class="number">+20</span>&gt;: retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>我们发现test2对应的汇编代码和test1对应的汇编代码完全相同，这说明C++编译器在编译程序的时候将指针和引用编译成了完全一样的机器码。**<u><em>所以C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同。</em></u>**</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，<strong>指针与引用底层实现都是一样的，不用担心两者的性能差距</strong>。</p><h3 id="宏那些事"><a href="#宏那些事" class="headerlink" title="宏那些事"></a>宏那些事</h3><h4 id="宏中包含特殊符号"><a href="#宏中包含特殊符号" class="headerlink" title="宏中包含特殊符号"></a>宏中包含特殊符号</h4><p>分为几种：<code>#</code>，<code>##</code>，<code>\</code></p><h5 id="1-字符串化操作符"><a href="#1-字符串化操作符" class="headerlink" title="1.字符串化操作符(#)"></a>1.字符串化操作符(#)</h5><p><strong>在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组</strong>，换言之就是：<strong>#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串</strong>。</p><p><strong>注意：其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exp(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp1(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,#s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp2(s) #s </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">exp</span>(<span class="string">&quot;hello&quot;</span>);                           <span class="comment">//**********************************这里传入的是字符串</span></span><br><span class="line">    <span class="built_in">exp1</span>(hello);                            <span class="comment">//**********************************这里传入的是个什么。。。</span></span><br><span class="line"></span><br><span class="line">    string str = <span class="built_in">exp2</span>(   bac );</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略传入参数名前面和后面的空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    string str1 = <span class="built_in">exp2</span>( asda  bac );</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，</span></span><br><span class="line"><span class="comment">     * 用每个子字符串之间以一个空格连接，忽略剩余空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str<span class="number">1.</span><span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-符号连接操作符（-）"><a href="#2-符号连接操作符（-）" class="headerlink" title="2.符号连接操作符（##）"></a>2.符号连接操作符（##）</h5><p><strong>“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。</strong></p><p>注意事项：</p><ul><li><strong>当用##连接形参时，##前后的空格可有可无。</strong></li><li><strong>连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。</strong></li><li><strong>如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> expA(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_##s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> expB(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_  ##  s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc_hello1 <span class="string">&quot;I am gc_hello1&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意事项1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * gc_hello = <span class="string">&quot;I am gc_hello&quot;</span>;</span><br><span class="line">    <span class="built_in">expA</span>(hello);</span><br><span class="line">    <span class="built_in">expB</span>(hello1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-续行操作符"><a href="#3-续行操作符" class="headerlink" title="3.续行操作符(\)"></a>3.续行操作符(\)</h5><p><strong>当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。</strong></p><p><strong>注意 \ 前留空格。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b) ? (a) \</span></span><br><span class="line"><span class="meta">   :(b))  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="built_in">MAX</span>(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;max_val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-…-while-0-的使用"><a href="#do-…-while-0-的使用" class="headerlink" title="do {…}while(0)的使用"></a>do {…}while(0)的使用</h4><h5 id="1-避免语义曲解"><a href="#1-避免语义曲解" class="headerlink" title="1.避免语义曲解"></a>1.避免语义曲解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fun() f1();f2();</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">fun</span>()</span><br></pre></td></tr></table></figure><p>这个宏被展开后就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure><p>本意是a&gt;0执行f1 f2，<strong>而实际是f2每次都会执行</strong>，所以就错误了。</p><p>为了解决这种问题，在写代码的时候，通常可以采用<code>{}</code>块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fun() &#123;f1();f2();&#125;</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line"><span class="comment">// 宏展开</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是会发现上述宏展开后多了一个分号，实际语法不太对。(虽然编译运行没问题，正常没分号)。</p><h5 id="2-避免由宏引起的警告"><a href="#2-避免由宏引起的警告" class="headerlink" title="2.避免由宏引起的警告"></a>2.避免由宏引起的警告</h5><p>内核中由于不同架构的限制，很多时候会用到空宏，。在编译的时候，这些空宏会给出warning，为了避免这样的warning，我们可以使用do{…}while(0)来定义空宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EMPTYMICRO do&#123;&#125;while(0)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自hexo博客的hello world</title>
      <link href="/2021/01/13/hello-world/"/>
      <url>/2021/01/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
